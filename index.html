<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Venus Dashboard V0.9beta</title>
    
    <!-- Chart.js for visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    
    <!-- jsPDF for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <!-- QR Code generator -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    
    <style>
        :root {
            /* Light Theme */
            --bg-primary: #f5f7fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e9ecef;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --accent-primary: #3498db;
            --accent-secondary: #2ecc71;
            --accent-danger: #e74c3c;
            --accent-warning: #f39c12;
            --border-color: #dee2e6;
            --shadow: rgba(0, 0, 0, 0.1);
            --overlay: rgba(0, 0, 0, 0.5);
            
            /* Spacing */
            --spacing-xs: 0.5rem;
            --spacing-sm: 1rem;
            --spacing-md: 1.5rem;
            --spacing-lg: 2rem;
            --spacing-xl: 3rem;
            
            /* Border Radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-xl: 16px;
            
            /* Transitions */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;
        }

        [data-theme="dark"] {
            --bg-primary: #1a1d23;
            --bg-secondary: #232830;
            --bg-tertiary: #2d333b;
            --text-primary: #e9ecef;
            --text-secondary: #adb5bd;
            --accent-primary: #4a9eff;
            --accent-secondary: #51cf66;
            --accent-danger: #ff6b6b;
            --accent-warning: #ffd43b;
            --border-color: #3d4450;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background var(--transition-normal), color var(--transition-normal);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Header */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .header-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: var(--spacing-sm) var(--spacing-md);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: var(--spacing-sm);
            position: relative;
        }

        /* Mobile Menu Button */
        .mobile-menu-btn {
            display: none;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: var(--spacing-xs);
            border-radius: var(--radius-md);
            transition: all var(--transition-fast);
            min-width: 44px;
            min-height: 44px;
            align-items: center;
            justify-content: center;
        }

        .mobile-menu-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
        }
        
        .mobile-menu-btn:active {
            transform: scale(0.95);
        }

        /* Mobile Navigation */
        .mobile-nav {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 4px 12px var(--shadow);
            z-index: 999;
            padding: var(--spacing-md);
        }

        .mobile-nav.active {
            display: block;
            animation: slideDown 0.3s ease-in-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .mobile-nav .header-actions {
            flex-direction: column;
            gap: var(--spacing-sm);
            align-items: stretch;
        }

        .mobile-nav .btn {
            justify-content: center;
            padding: var(--spacing-sm);
            font-size: 1rem;
            min-height: 48px;
            width: 100%;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }
        
        .mobile-nav .btn-icon {
            justify-content: flex-start;
        }
        
        .mobile-nav .lock-btn {
            font-size: 1rem;
        }
        
        .mobile-nav .lock-btn span:first-child {
            font-size: 1.2rem;
        }

        .mobile-nav-section {
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--border-color);
        }

        .mobile-nav-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .mobile-nav-title {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: var(--spacing-sm);
            font-weight: 600;
        }

        .mobile-view-modes {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .mobile-filters {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
        }

        .mobile-filters .filter-input {
            width: 100%;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #ff8c00, #ffa500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .project-selector {
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .project-selector:hover {
            border-color: var(--accent-primary);
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            flex-wrap: wrap;
        }

        .btn {
            padding: var(--spacing-xs) var(--spacing-md);
            border: none;
            border-radius: var(--radius-md);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            font-weight: 500;
        }

        .btn-primary {
            background: var(--accent-primary);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--border-color);
        }

        .btn-icon {
            background: transparent;
            color: var(--text-primary);
            padding: var(--spacing-xs);
            font-size: 1.2rem;
        }

        .btn-icon:hover {
            background: var(--bg-tertiary);
        }

        .lock-btn {
            position: relative;
            transition: all 0.3s ease;
        }

        .lock-btn:hover {
            background: var(--bg-tertiary);
            transform: scale(1.05);
        }

        .lock-btn.locked {
            background: var(--danger-color);
            color: white;
        }

        .lock-btn.unlocked {
            background: var(--success-color);
            color: white;
        }

        .lock-btn.unlocked:hover {
            background: var(--success-hover);
        }

        /* Restricted Mode overlay styles */
        .restricted-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-secondary);
            z-index: 10;
            border-top: 1px solid var(--border-color);
        }
        .restricted-overlay-inner {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--spacing-sm);
            text-align: center;
            padding: var(--spacing-md);
            border-radius: var(--radius-md);
        }
        .restricted-overlay-icon {
            font-size: 2rem;
            opacity: 0.7;
            color: var(--text-secondary);
        }
        .restricted-overlay-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.4;
        }
        .restricted-widget {
            position: relative;
        }
        .restricted-widget::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            pointer-events: none;
            z-index: 1;
        }

        .restricted-hidden {
            color: var(--text-secondary) !important;
            font-style: italic;
            filter: blur(1px);
            user-select: none;
            transition: all 0.3s ease;
        }

        /* Auto-save indicator */
        .auto-save-indicator {
            display: flex;
            align-items: center;
            padding: var(--spacing-xs);
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
            cursor: pointer;
        }

        .auto-save-indicator.saving {
            background: rgba(46, 204, 113, 0.1);
            color: var(--accent-secondary);
        }

        .auto-save-indicator.saved {
            background: rgba(52, 152, 219, 0.1);
            color: var(--accent-primary);
        }

        .auto-save-indicator.error {
            background: rgba(231, 76, 60, 0.1);
            color: var(--accent-danger);
        }

        .auto-save-indicator.disabled {
            background: rgba(108, 117, 125, 0.1);
            color: var(--text-secondary);
            opacity: 0.5;
        }

        /* Toolbar */
        .toolbar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: var(--spacing-sm) var(--spacing-md);
            transition: all var(--transition-normal);
        }

        .toolbar.sticky {
            position: sticky;
            top: 80px; /* Position below header */
            z-index: 999;
            box-shadow: 0 2px 8px var(--shadow);
        }

        .toolbar.collapsed {
            transform: translateY(-100%);
            opacity: 0;
        }

        .toolbar-toggle {
            position: fixed;
            top: 90px; /* Position below header */
            right: 20px;
            z-index: 1000;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px var(--shadow);
            transition: all var(--transition-normal);
            font-size: 1.2rem;
        }

        .toolbar-toggle:hover {
            background: var(--accent-secondary);
            transform: scale(1.1);
        }

        .toolbar-toggle.collapsed {
            background: var(--text-secondary);
        }

        .toolbar-toggle.collapsed:hover {
            background: var(--accent-primary);
        }

        .toolbar-container {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: var(--spacing-sm);
        }

        .view-modes {
            display: flex;
            gap: var(--spacing-xs);
        }

        .view-mode-btn {
            padding: var(--spacing-xs) var(--spacing-md);
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .view-mode-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .filters {
            display: flex;
            gap: var(--spacing-xs);
            flex-wrap: wrap;
        }

        .filter-input {
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        /* Main Container */
        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: var(--spacing-md);
        }

        /* KPI Cards */
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .kpi-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            box-shadow: 0 2px 8px var(--shadow);
            transition: all var(--transition-normal);
            position: relative;
            overflow: hidden;
        }

        .kpi-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--kpi-color, var(--accent-primary));
        }

        .kpi-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px var(--shadow);
        }

        .kpi-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: var(--spacing-sm);
        }

        .kpi-title {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .kpi-icon {
            font-size: 1.5rem;
            opacity: 0.5;
        }

        .kpi-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .kpi-trend {
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            transition: all var(--transition-fast);
        }

        .kpi-trend.positive {
            color: var(--accent-secondary);
        }

        .kpi-trend.negative {
            color: var(--accent-danger);
        }


        /* Dashboard Grid */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .widget {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            box-shadow: 0 2px 8px var(--shadow);
            position: relative;
            transition: all var(--transition-normal);
        }

        .widget.dragging {
            opacity: 0.8;
            cursor: move;
            transform: scale(0.95);
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .widget.drag-over {
            transform: scale(1.02);
            transition: transform 0.2s ease;
        }

        .widget.drag-insert-before {
            border-top: 3px solid var(--accent-primary);
            transform: translateY(-2px);
            transition: all 0.2s ease;
        }

        .widget.drag-insert-after {
            border-bottom: 3px solid var(--accent-primary);
            transform: translateY(2px);
            transition: all 0.2s ease;
        }

        .widget.drag-placeholder {
            opacity: 0.3;
            transform: scale(0.98);
            transition: all 0.2s ease;
        }

        .widget-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            cursor: move;
        }

        .widget-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .widget-actions {
            display: flex;
            gap: var(--spacing-xs);
        }

        .widget-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: var(--spacing-xs);
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
        }

        .widget-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Add Widget Widget */
        .add-widget-widget {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
            cursor: pointer;
            transition: all var(--transition-normal);
            border: 2px dashed var(--border-color);
            background: var(--bg-secondary);
        }

        .add-widget-widget:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
            transform: scale(1.02);
        }

        .add-widget-icon {
            font-size: 3rem;
            color: var(--accent-primary);
            transition: all var(--transition-normal);
        }

        .add-widget-widget:hover .add-widget-icon {
            transform: scale(1.1);
            color: var(--accent-secondary);
        }

        /* Widget Sizes */
        .widget-small { grid-column: span 3; }
        .widget-medium { grid-column: span 6; }
        .widget-large { grid-column: span 9; }
        .widget-full { grid-column: span 12; }

        /* Responsive adjustments */
        /* Tablet Styles */
        @media (max-width: 1024px) {
            .widget-small, .widget-medium { grid-column: span 6; }
            .widget-large, .widget-full { grid-column: span 12; }
            
            .header-container {
                padding: var(--spacing-sm);
            }
            
            .main-container {
                padding: var(--spacing-sm);
            }
            
            .chart-container {
                height: 250px;
            }
        }

        /* Mobile Floating Add Button */
        .mobile-add-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: var(--accent-primary);
            color: white;
            border: none;
            border-radius: 50%;
            box-shadow: 0 4px 12px var(--shadow);
            cursor: pointer;
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: all var(--transition-normal);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .mobile-add-button:hover {
            background: var(--accent-secondary);
            transform: scale(1.1);
        }

        .mobile-add-button:active {
            transform: scale(0.95);
        }
        /* Mobile Styles */
        @media (max-width: 768px) {
            /* Mobile Menu Button */
            .mobile-menu-btn {
                display: flex;
            }
            
            /* Mobile Floating Add Button */
            .mobile-add-button {
                display: flex;
            }
            
            /* Hide desktop Add Widget button on mobile */
            .header-actions {
                display: none;
            }
            
            .logo {
                font-size: 1.2rem;
            }
            
            /* Layout */
            .widget-small, .widget-medium, .widget-large, .widget-full {
                grid-column: span 12;
            }
            
            .widget {
                margin-bottom: var(--spacing-sm);
            }
            
            .widget-body {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .kpi-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: var(--spacing-sm);
            }
            
            .kpi-card {
                padding: var(--spacing-sm);
                touch-action: manipulation;
            }
            
            .main-container {
                padding: var(--spacing-xs) var(--spacing-sm);
                gap: var(--spacing-sm);
            }
            
            /* Typography */
            .widget-title {
                font-size: 1.1rem;
            }
            
            .kpi-value {
                font-size: 1.5rem;
            }
            
            .kpi-label {
                font-size: 0.8rem;
            }
            
            /* Charts */
            .chart-container {
                height: 200px;
                margin-top: var(--spacing-xs);
            }
            
            /* Tables */
            .data-table {
                font-size: 0.85rem;
            }
            
            .data-table th,
            .data-table td {
                padding: var(--spacing-xs);
            }
            
            /* Buttons */
            .btn {
                min-height: 44px;
                font-size: 0.9rem;
                padding: var(--spacing-sm);
            }
            
            .btn-icon {
                min-width: 44px;
                min-height: 44px;
                padding: var(--spacing-xs);
            }
            
            /* Widget Headers - Remove cursor:move on mobile since dragging is disabled */
            .widget-header {
                cursor: default !important;
                -webkit-tap-highlight-color: transparent;
            }
            
            .widget {
                -webkit-overflow-scrolling: touch;
            }
            
            /* Prevent text selection during scrolling on mobile */
            .widget-header, .widget-title {
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
            
            /* Toolbar - Hide on mobile since we have mobile menu */
            .toolbar {
                display: none;
            }
            
            .toolbar-toggle {
                display: none;
            }
            
            .toolbar-container {
                padding: var(--spacing-sm);
                flex-wrap: wrap;
                gap: var(--spacing-sm);
            }
            
            .view-modes {
                flex-wrap: wrap;
                gap: var(--spacing-xs);
            }
            
            .view-mode-btn {
                min-height: 44px;
                padding: var(--spacing-xs) var(--spacing-sm);
                font-size: 0.85rem;
                flex: 1;
                min-width: 120px;
            }
            
            
            /* Modals */
            .modal-content {
                margin: var(--spacing-sm);
                max-width: calc(100vw - 2rem);
                max-height: calc(100vh - 2rem);
            }
            
            .modal-header {
                padding: var(--spacing-sm);
            }
            
            .modal-body {
                padding: var(--spacing-sm);
            }
            
            .modal-footer {
                padding: var(--spacing-sm);
                flex-direction: column;
                gap: var(--spacing-xs);
            }
            
            .modal-footer .btn {
                width: 100%;
            }
        }

        /* Small Mobile Styles */
        @media (max-width: 480px) {
            .logo {
                font-size: 1rem;
            }
            
            .header-container {
                padding: var(--spacing-xs) var(--spacing-sm);
            }
            
            .mobile-menu-btn {
                font-size: 1.3rem;
            }
            
            .kpi-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: var(--spacing-xs);
            }
            
            .kpi-card {
                padding: var(--spacing-xs);
            }
            
            .kpi-value {
                font-size: 1.3rem;
            }
            
            .chart-container {
                height: 180px;
            }
            
            .data-table {
                font-size: 0.8rem;
            }
            
            .widget {
                padding: var(--spacing-sm);
            }
            
            .widget-title {
                font-size: 1rem;
            }
            
            .modal-title {
                font-size: 1.2rem;
            }
            
            .widget-header {
                padding-bottom: var(--spacing-xs);
            }
            
            .mobile-booking-card {
                padding: var(--spacing-sm);
            }
            
            .mobile-booking-details {
                grid-template-columns: 1fr;
            }
            
            .mobile-booking-services {
                grid-column: span 1;
            }
        }

        /* Mobile Form Enhancements */
        @media (max-width: 768px) {
            input, select, textarea {
                font-size: 16px; /* Prevents zoom on iOS */
                min-height: 44px;
                padding: var(--spacing-sm);
            }
            
            .form-group {
                margin-bottom: var(--spacing-md);
            }
            
            .form-group label {
                display: block;
                margin-bottom: var(--spacing-xs);
                font-weight: 600;
            }
            
            .filter-controls {
                flex-direction: column;
                gap: var(--spacing-sm);
            }
            
            .filter-controls > div {
                width: 100%;
            }
            
            .filter-controls select,
            .filter-controls input {
                width: 100%;
            }
        }

        /* Touch-friendly enhancements */
        @media (hover: none) and (pointer: coarse) {
            .btn:hover {
                transform: none;
            }
            
            .widget:hover {
                transform: none;
            }
            
            .kpi-card:hover {
                transform: none;
            }
            
            /* Increase touch targets */
            .btn {
                min-height: 48px;
                min-width: 48px;
            }
            
            .btn-icon {
                min-height: 48px;
                min-width: 48px;
            }
        }

        /* Chart Container */
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: var(--spacing-sm);
        }

        /* Calendar Widget Styles */
        .calendar-container {
            padding: var(--spacing-sm);
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            flex-wrap: wrap;
            gap: var(--spacing-sm);
        }

        .calendar-nav {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .calendar-nav-btn {
            padding: var(--spacing-xs) var(--spacing-sm);
            font-size: 1.2rem;
            font-weight: bold;
            min-width: 40px;
        }

        .calendar-title {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
            min-width: 150px;
            text-align: center;
        }

        .calendar-view-toggle {
            display: flex;
            gap: var(--spacing-xs);
        }

        .calendar-view-btn {
            padding: var(--spacing-xs) var(--spacing-sm);
            font-size: 0.9rem;
        }

        .calendar-view-btn.active {
            background: var(--accent-primary);
            color: white;
        }

        .calendar-filter-status,
        .booking-list-filter-status {
            margin: var(--spacing-sm) 0;
            padding: var(--spacing-xs) var(--spacing-sm);
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            border-left: 4px solid var(--accent-primary);
            font-size: 0.85rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            flex-wrap: wrap;
        }

        .calendar-filter-status.has-filters,
        .booking-list-filter-status.has-filters {
            background: var(--accent-primary);
            color: white;
            border-left-color: var(--accent-secondary);
        }

        .filter-status-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .calendar-filter-status:not(.has-filters) .filter-status-item,
        .booking-list-filter-status:not(.has-filters) .filter-status-item {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .filter-status-icon {
            font-size: 0.7rem;
        }

        .calendar-content {
            min-height: 400px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        /* Month View */
        .calendar-month {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            height: 100%;
        }

        .calendar-day-header {
            background: var(--bg-tertiary);
            padding: var(--spacing-sm);
            text-align: center;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
        }

        .calendar-day {
            min-height: 80px;
            border-right: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            padding: var(--spacing-xs);
            position: relative;
            background: var(--bg-secondary);
            transition: background-color var(--transition-fast);
        }

        .calendar-day:hover {
            background: var(--bg-tertiary);
        }

        .calendar-day.other-month {
            background: var(--bg-primary);
            color: var(--text-secondary);
        }

        .calendar-day.today {
            background: var(--accent-primary);
            color: white;
            font-weight: bold;
        }

        .calendar-day-number {
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: var(--spacing-xs);
        }

        .calendar-bookings {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .calendar-booking {
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all var(--transition-fast);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .calendar-booking:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 4px var(--shadow);
        }

        .calendar-booking.pending {
            background: #ff9500;
            color: white;
        }

        .calendar-booking.confirmed {
            background: #34c759;
            color: white;
        }

        .calendar-booking.cancelled {
            background: #ff3b30;
            color: white;
        }

        /* Week View */
        .calendar-week {
            display: grid;
            grid-template-columns: 80px repeat(7, 1fr);
            height: 100%;
        }

        .calendar-time-column {
            background: var(--bg-tertiary);
            border-right: 1px solid var(--border-color);
        }

        .calendar-time-slot {
            height: 40px;
            border-bottom: 1px solid var(--border-color);
            padding: var(--spacing-xs);
            font-size: 0.8rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
        }

        .calendar-week-day {
            border-right: 1px solid var(--border-color);
            position: relative;
        }

        .calendar-week-day-header {
            background: var(--bg-tertiary);
            padding: var(--spacing-sm);
            text-align: center;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
        }

        .calendar-week-slot {
            height: 40px;
            border-bottom: 1px solid var(--border-color);
            position: relative;
            background: var(--bg-secondary);
        }

        .calendar-week-booking {
            position: absolute;
            left: 2px;
            right: 2px;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.7rem;
            cursor: pointer;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            transition: all var(--transition-fast);
        }

        .calendar-week-booking:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 4px var(--shadow);
        }

        .calendar-week-booking.pending {
            background: #ff9500;
            color: white;
        }

        .calendar-week-booking.confirmed {
            background: #34c759;
            color: white;
        }

        .calendar-week-booking.cancelled {
            background: #ff3b30;
            color: white;
        }

        /* Day View */
        .calendar-day-view {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .calendar-day-header-view {
            background: var(--bg-tertiary);
            padding: var(--spacing-sm);
            text-align: center;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .calendar-day-time-slots {
            flex: 1;
            overflow-y: auto;
        }

        .calendar-day-slot {
            height: 60px;
            border-bottom: 1px solid var(--border-color);
            padding: var(--spacing-sm);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            background: var(--bg-secondary);
            transition: background-color var(--transition-fast);
        }

        .calendar-day-slot:hover {
            background: var(--bg-tertiary);
        }

        .calendar-day-slot-time {
            font-weight: 600;
            color: var(--text-primary);
            min-width: 60px;
        }

        .calendar-day-slot-bookings {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .calendar-day-booking {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .calendar-day-booking:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 4px var(--shadow);
        }

        .calendar-day-booking.pending {
            background: #ff9500;
            color: white;
        }

        .calendar-day-booking.confirmed {
            background: #34c759;
            color: white;
        }

        .calendar-day-booking.cancelled {
            background: #ff3b30;
            color: white;
        }

        /* Calendar Legend */
        .calendar-legend {
            display: flex;
            justify-content: center;
            gap: var(--spacing-md);
            margin-top: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .legend-color.pending {
            background: #ff9500;
        }

        .legend-color.confirmed {
            background: #34c759;
        }

        .legend-color.cancelled {
            background: #ff3b30;
        }

        /* Mobile Calendar Styles */
        @media (max-width: 768px) {
            .calendar-header {
                flex-direction: column;
                align-items: stretch;
                gap: var(--spacing-sm);
            }

            .calendar-nav {
                justify-content: center;
            }

            .calendar-view-toggle {
                justify-content: center;
            }

            .calendar-content {
                min-height: 300px;
            }

            .calendar-day {
                min-height: 60px;
                padding: 2px;
            }

            .calendar-booking {
                font-size: 0.7rem;
                padding: 1px 2px;
            }

            .calendar-week {
                grid-template-columns: 60px repeat(7, 1fr);
            }

            .calendar-time-slot {
                height: 30px;
                font-size: 0.7rem;
            }

            .calendar-week-slot {
                height: 30px;
            }

            .calendar-day-slot {
                height: 50px;
                padding: var(--spacing-xs);
            }

            .calendar-day-slot-time {
                min-width: 50px;
                font-size: 0.9rem;
            }

            .calendar-legend {
                flex-wrap: wrap;
                gap: var(--spacing-sm);
            }

            .legend-item {
                font-size: 0.8rem;
            }
        }

        @media (max-width: 480px) {
            .calendar-day {
                min-height: 50px;
            }

            .calendar-booking {
                font-size: 0.65rem;
            }

            .calendar-week {
                grid-template-columns: 50px repeat(7, 1fr);
            }

            .calendar-time-slot {
                height: 25px;
                font-size: 0.65rem;
            }

            .calendar-week-slot {
                height: 25px;
            }

            .calendar-day-slot {
                height: 45px;
            }

            .calendar-day-slot-time {
                min-width: 45px;
                font-size: 0.8rem;
            }
        }

        /* Booking Details Modal Styles */
        .booking-details {
            padding: var(--spacing-sm);
        }

        .detail-section {
            margin-bottom: var(--spacing-lg);
        }

        .detail-section h3 {
            margin: 0 0 var(--spacing-sm) 0;
            color: var(--text-primary);
            font-size: 1.1rem;
            font-weight: 600;
            border-bottom: 2px solid var(--accent-primary);
            padding-bottom: var(--spacing-xs);
        }

        .detail-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-sm);
        }

        .detail-item {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .detail-item.full-width {
            grid-column: 1 / -1;
        }

        .detail-item label {
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .detail-item span {
            color: var(--text-primary);
            font-size: 0.95rem;
        }

        .status-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-badge.pending {
            background: #ff9500;
            color: white;
        }

        .status-badge.confirmed {
            background: #34c759;
            color: white;
        }

        .status-badge.cancelled {
            background: #ff3b30;
            color: white;
        }

        .services-list {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-xs);
        }

        .service-tag {
            background: var(--accent-primary);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .modal-actions {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
        }

        .btn-danger {
            background: #ff3b30;
            color: white;
        }
        .btn-danger:hover {
            background: #d70015;
        }

        .btn-warning {
            background: #ff9500;
            color: white;
        }

        .btn-warning:hover {
            background: #e6850e;
        }

        .btn-success {
            background: #34c759;
            color: white;
        }

        .btn-success:hover {
            background: #30b04f;
        }

        @media (max-width: 768px) {
            .detail-grid {
                grid-template-columns: 1fr;
            }

            .modal-actions {
                flex-direction: column;
            }

            .modal-actions .btn {
                width: 100%;
            }
        }

        /* Table Styles */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: var(--spacing-sm);
        }

        /* Responsive Table Container */
        .table-responsive {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            border-radius: var(--radius-md);
            box-shadow: 0 2px 8px var(--shadow);
        }

        /* Mobile Table Styles */
        @media (max-width: 768px) {
            .table-responsive .data-table {
                display: none !important;
            }
            
            .table-responsive {
                border: 1px solid var(--border-color);
            }
            
            .mobile-booking-cards {
                display: flex !important;
                flex-direction: column;
                gap: var(--spacing-sm);
                width: 100%;
                margin-top: var(--spacing-sm);
            }
            
            .mobile-booking-card {
                width: 100%;
                box-sizing: border-box;
            }
        }

        /* Desktop - Hide mobile cards */
        @media (min-width: 769px) {
            .mobile-booking-cards {
                display: none !important;
            }
            
            .table-responsive .data-table {
                display: table !important;
            }
        }

        /* Mobile Booking Cards */
        .mobile-booking-cards {
            display: none;
            gap: var(--spacing-sm);
            width: 100%;
        }


        .mobile-booking-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--spacing-md);
            box-shadow: 0 2px 8px var(--shadow);
            transition: all var(--transition-fast);
        }

        .mobile-booking-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .mobile-booking-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: var(--spacing-sm);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid var(--border-color);
        }

        .mobile-booking-date {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 1.1rem;
        }

        .mobile-booking-status {
            padding: var(--spacing-xs) var(--spacing-sm);
            border-radius: var(--radius-sm);
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .mobile-booking-customer {
            margin-bottom: var(--spacing-sm);
        }

        .mobile-booking-customer-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .mobile-booking-customer-email {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .mobile-booking-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
        }

        .mobile-booking-detail {
            display: flex;
            flex-direction: column;
        }

        .mobile-booking-detail-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--spacing-xs);
            font-weight: 600;
        }

        .mobile-booking-detail-value {
            font-weight: 500;
            color: var(--text-primary);
        }

        .mobile-booking-services {
            grid-column: span 2;
        }

        .mobile-booking-total {
            text-align: right;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent-secondary);
            margin-top: var(--spacing-sm);
            padding-top: var(--spacing-sm);
            border-top: 1px solid var(--border-color);
        }

        /* Status badge styles for mobile */
        .mobile-booking-status.status-confirmed {
            background: #d4edda;
            color: #155724;
        }

        .mobile-booking-status.status-pending {
            background: #fff3cd;
            color: #856404;
        }

        .mobile-booking-status.status-cancelled {
            background: #f8d7da;
            color: #721c24;
        }

        .mobile-booking-status.status-completed {
            background: #d1ecf1;
            color: #0c5460;
        }

        .data-table thead {
            background: var(--bg-tertiary);
        }

        .data-table th,
        .data-table td {
            padding: var(--spacing-sm);
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .data-table th {
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .data-table tbody tr {
            transition: background var(--transition-fast);
        }

        .data-table tbody tr:hover {
            background: var(--bg-tertiary);
        }

        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-confirmed {
            background: rgba(46, 204, 113, 0.1);
            color: var(--accent-secondary);
        }

        .status-pending {
            background: rgba(243, 156, 18, 0.1);
            color: var(--accent-warning);
        }

        .status-cancelled {
            background: rgba(231, 76, 60, 0.1);
            color: var(--accent-danger);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--overlay);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-md);
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px var(--shadow);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .modal-body {
            padding: var(--spacing-md) 0;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-sm);
            padding-top: var(--spacing-md);
            border-top: 1px solid var(--border-color);
        }

        .form-group {
            margin-bottom: var(--spacing-md);
        }

        .form-group label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-weight: 600;
            color: var(--text-primary);
        }

        .form-input {
            width: 100%;
            padding: var(--spacing-sm);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 1rem;
            transition: all var(--transition-fast);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px rgba(var(--accent-primary-rgb), 0.1);
        }

        .form-help {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: var(--spacing-xs);
        }

        .custom-layout-btn {
            background: var(--accent-secondary);
            color: var(--text-primary);
            border: 1px solid var(--accent-secondary);
            position: relative;
        }

        .custom-layout-btn.active {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }

        .custom-layout-btn .layout-actions {
            position: absolute;
            right: -5px;
            top: -5px;
            display: none;
            gap: 2px;
        }

        .custom-layout-btn:hover .layout-actions {
            display: flex;
        }

        .layout-action-btn {
            width: 16px;
            height: 16px;
            padding: 0;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-primary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .layout-action-btn:hover {
            background: var(--accent-danger);
            color: white;
            border-color: var(--accent-danger);
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: color var(--transition-fast);
        }

        .close-btn:hover {
            color: var(--text-primary);
        }

        /* Export Options */
        .export-options {
            display: grid;
            gap: var(--spacing-sm);
        }

        .export-option {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-md);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .export-option:hover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }

        .export-option input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }

        /* ============================================================================
           ENHANCED PDF EXPORT SYSTEM - Improved Version (Styles)
           ============================================================================ */

        .export-section {
            margin-bottom: var(--spacing-lg);
        }

        .export-widget-section {
            margin-bottom: var(--spacing-md);
        }

        .export-sub-options {
            margin-top: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            border-left: 3px solid var(--accent-primary);
        }

        .export-select,
        .export-input {
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.9rem;
            min-width: 150px;
        }

        .export-select:focus,
        .export-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 2px var(--accent-primary-alpha);
        }

        /* Loading Spinner */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Ensure refresh button itself does not rotate */
        .widget.refreshing .widget-actions .widget-btn {
            animation: none !important;
        }

        /* Widget refresh animation: show a spinner centered over the chart area */
        .widget.refreshing .chart-container::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 36px;
            height: 36px;
            margin-left: -18px;
            margin-top: -18px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            z-index: 2;
            pointer-events: none;
        }

        .widget.refreshing .chart-container {
            opacity: 0.9;
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: var(--spacing-md);
            right: var(--spacing-md);
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: var(--spacing-md);
            border-radius: var(--radius-md);
            box-shadow: 0 4px 12px var(--shadow);
            border-left: 4px solid var(--accent-primary);
            z-index: 3000;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-sm);
            margin-top: var(--spacing-sm);
        }

        .stat-item {
            padding: var(--spacing-sm);
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* Service Pills */
        .service-pills {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-xs);
        }

        .service-pill {
            padding: 0.25rem 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 12px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
                color: black;
            }
            
            .header, .toolbar, .widget-actions, .no-print {
                display: none !important;
            }
            
            .widget {
                break-inside: avoid;
                page-break-inside: avoid;
            }
        }

        /* Resize Handle */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity var(--transition-fast);
        }

        .widget:hover .resize-handle {
            opacity: 0.5;
        }

        .resize-handle::after {
            content: '⋰';
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 1rem;
            color: var(--text-secondary);
        }

        /* Custom Empty State */
        .custom-empty-state {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 60vh;
            background: var(--bg-secondary);
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-lg);
            margin: var(--spacing-md) 0;
        }

        .custom-empty-content {
            text-align: center;
            padding: 3rem;
            color: var(--text-primary);
            max-width: 500px;
        }

        .custom-empty-icon {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            opacity: 1;
        }

        .custom-empty-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        .custom-empty-description {
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 2rem;
            color: var(--text-primary);
            opacity: 0.9;
        }

        .custom-empty-button {
            font-size: 1.1rem;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-md);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-container">
            <div class="logo-section">
                <div class="logo">🌍 Venus DASH V0.9beta</div>
            </div>
            
            <!-- Mobile Menu Button -->
            <button class="mobile-menu-btn" id="mobileMenuBtn" title="Menu">
                <span id="mobileMenuIcon">☰</span>
            </button>
            
            <!-- Desktop Actions -->
            <div class="header-actions">
                <button class="btn btn-icon lock-btn" id="lockBtn" title="Toggle Restricted Mode" onclick="toggleRestrictedMode()">
                    <span id="lockIcon">🔒</span>
                </button>
                <button class="btn btn-primary" id="exportBtn">
                    <span>📄</span> Export
                </button>
                <button class="btn btn-secondary" onclick="manualSave()" title="Manual Save">
                    <span>💾</span> Save Now
                </button>
                <button class="btn btn-icon" id="themeToggle" title="Toggle Theme">
                    <span id="themeIcon">🌙</span>
                </button>
                <div class="auto-save-indicator" id="autoSaveIndicator" title="Auto-save status" onclick="testSave()">
                    <span id="autoSaveIcon">💾</span>
                </div>
            </div>
            
            <!-- Mobile Navigation -->
            <div class="mobile-nav" id="mobileNav">
                <!-- Actions Section -->
                <div class="mobile-nav-section">
                    <h4 class="mobile-nav-title">Actions</h4>
                    <div class="header-actions">
                        <button class="btn btn-icon lock-btn" id="lockBtnMobile" title="Toggle Restricted Mode" onclick="toggleRestrictedMode()">
                            <span id="lockIconMobile">🔒</span>
                            <span>Restricted Mode</span>
                        </button>
                        <button class="btn btn-primary" id="exportBtnMobile">
                            <span>📄</span> Export
                        </button>
                        <button class="btn btn-secondary" onclick="manualSave()" title="Manual Save">
                            <span>💾</span> Save Now
                        </button>
                        <button class="btn btn-icon" id="themeToggleMobile" title="Toggle Theme">
                            <span id="themeIconMobile">🌙</span>
                            <span>Theme</span>
                        </button>
                    </div>
                </div>

                <!-- Views Section -->
                <div class="mobile-nav-section">
                    <h4 class="mobile-nav-title">Views</h4>
                    <div class="mobile-view-modes" id="mobileViewModes">
                        <button class="view-mode-btn active" data-view="full" onclick="closeMobileMenu()">Full View</button>
                        <button class="view-mode-btn" data-view="custom" id="customBtnMobile" onclick="closeMobileMenu()">Custom</button>
                    </div>
                </div>

                <!-- Filters Section -->
                <div class="mobile-nav-section">
                    <h4 class="mobile-nav-title">Filters</h4>
                    <div class="mobile-filters">
                        <select id="timePeriodFilterMobile" class="filter-input">
                            <option value="">All Time</option>
                            <option value="thisWeek">This Week</option>
                            <option value="thisMonth">This Month</option>
                            <option value="lastMonth">Last Month</option>
                            <option value="jan2025">Jan 2025</option>
                            <option value="feb2025">Feb 2025</option>
                            <option value="mar2025">Mar 2025</option>
                            <option value="apr2025">Apr 2025</option>
                            <option value="may2025">May 2025</option>
                            <option value="jun2025">Jun 2025</option>
                            <option value="jul2025">Jul 2025</option>
                            <option value="aug2025">Aug 2025</option>
                            <option value="sep2025">Sep 2025</option>
                            <option value="oct2025">Oct 2025</option>
                            <option value="nov2025">Nov 2025</option>
                            <option value="dec2025">Dec 2025</option>
                        </select>
                        <select id="statusFilterMobile" class="filter-input">
                            <option value="">All Status</option>
                            <option value="confirmed">Confirmed</option>
                            <option value="pending">Pending</option>
                            <option value="cancelled">Cancelled</option>
                        </select>
                        <button class="btn btn-secondary" id="applyFiltersMobile">Apply Filters</button>
                        <button class="btn btn-secondary" id="resetFiltersMobile">Reset</button>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Toolbar -->
    <div class="toolbar sticky" id="toolbar">
        <div class="toolbar-container">
            <div class="view-modes">
                <button class="view-mode-btn active" data-view="full">Full View</button>
                <button class="view-mode-btn" data-view="custom" id="customBtn">Custom</button>
                <!-- Dynamic custom layout buttons will be inserted here -->
            </div>
            
            <div class="filters">
                <select id="timePeriodFilter" class="filter-input">
                    <option value="">All Time</option>
                    <option value="thisWeek">This Week</option>
                    <option value="thisMonth">This Month</option>
                    <option value="lastMonth">Last Month</option>
                    <option value="jan2025">Jan 2025</option>
                    <option value="feb2025">Feb 2025</option>
                    <option value="mar2025">Mar 2025</option>
                    <option value="apr2025">Apr 2025</option>
                    <option value="may2025">May 2025</option>
                    <option value="jun2025">Jun 2025</option>
                    <option value="jul2025">Jul 2025</option>
                    <option value="aug2025">Aug 2025</option>
                    <option value="sep2025">Sep 2025</option>
                    <option value="oct2025">Oct 2025</option>
                    <option value="nov2025">Nov 2025</option>
                    <option value="dec2025">Dec 2025</option>
                </select>
                <select id="statusFilter" class="filter-input">
                    <option value="">All Status</option>
                    <option value="confirmed">Confirmed</option>
                    <option value="pending">Pending</option>
                    <option value="cancelled">Cancelled</option>
                </select>
                <button class="btn btn-secondary" id="applyFilters">Apply Filters</button>
                <button class="btn btn-secondary" id="resetFilters">Reset</button>
            </div>
        </div>
    </div>

    <!-- Toolbar Toggle Button -->
    <button class="toolbar-toggle" id="toolbarToggle" onclick="toggleToolbar()" title="Toggle toolbar">
        📋
    </button>

    <!-- Mobile Floating Add Button -->
    <button class="mobile-add-button" id="mobileAddButton" onclick="openModal('addWidgetModal')" title="Add Widget">
        +
    </button>

    <!-- Main Dashboard -->
    <main class="main-container">
        <!-- KPI Cards -->
        <div class="kpi-grid" id="kpiGrid">
            <!-- KPIs will be dynamically generated -->
        </div>

        <!-- Dashboard Widgets -->
        <div class="dashboard-grid" id="dashboardGrid">
            <!-- Widgets will be dynamically generated -->
        </div>
    </main>

    <!-- Export Modal -->
    <div class="modal" id="exportModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2 class="modal-title">Export Dashboard Report</h2>
                <button class="close-btn" onclick="closeModal('exportModal')">&times;</button>
            </div>
            
            <!-- Report Configuration -->
            <div class="export-section">
                <h3 style="margin-bottom: var(--spacing-md); color: var(--text-primary);">Report Configuration</h3>
                
                <!-- Bookings Section -->
                <div class="export-widget-section">
                    <label class="export-option">
                        <input type="checkbox" name="exportItem" value="bookings" checked onchange="toggleExportSection('bookings')">
                        <div>
                            <strong>📋 Bookings List</strong>
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Include booking details in table format</div>
                        </div>
                    </label>
                    <div id="bookingsOptions" class="export-sub-options">
                        <div style="margin-left: 30px; margin-top: var(--spacing-sm);">
                            <label style="display: block; margin-bottom: var(--spacing-xs);">Time Range:</label>
                            <select id="bookingsTimeRange" class="export-select">
                                <option value="this-week">This Week</option>
                                <option value="this-month" selected>This Month</option>
                                <option value="last-month">Last Month</option>
                                <option value="last-3-months">Last 3 Months</option>
                                <option value="custom">Custom Range</option>
                            </select>
                            <div id="customDateRange" style="margin-top: var(--spacing-sm); display: none;">
                                <input type="date" id="startDate" class="export-input" style="margin-right: var(--spacing-sm);">
                                <span style="margin: 0 var(--spacing-xs);">to</span>
                                <input type="date" id="endDate" class="export-input">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Revenue Chart Section -->
                <div class="export-widget-section">
                    <label class="export-option">
                        <input type="checkbox" name="exportItem" value="revenue-chart" checked onchange="toggleExportSection('revenue-chart')">
                        <div>
                            <strong>📊 Revenue Chart</strong>
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Revenue over time visualization</div>
                        </div>
                    </label>
                    <div id="revenue-chartOptions" class="export-sub-options">
                        <div style="margin-left: 30px; margin-top: var(--spacing-sm);">
                            <label style="display: block; margin-bottom: var(--spacing-xs);">Chart Period:</label>
                            <select id="revenueTimeRange" class="export-select">
                                <option value="past-week">Past Week</option>
                                <option value="past-month" selected>Past Month</option>
                                <option value="last-3-months">Last 3 Months</option>
                                <option value="last-6-months">Last 6 Months</option>
                                <option value="this-year">This Year</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Service Distribution Section -->
                <div class="export-widget-section">
                    <label class="export-option">
                        <input type="checkbox" name="exportItem" value="service-distribution" onchange="toggleExportSection('service-distribution')">
                        <div>
                            <strong>🥧 Service Distribution</strong>
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Service popularity pie chart</div>
                        </div>
                    </label>
                    <div id="service-distributionOptions" class="export-sub-options" style="display: none;">
                        <div style="margin-left: 30px; margin-top: var(--spacing-sm);">
                            <label style="display: block; margin-bottom: var(--spacing-xs);">Analysis Period:</label>
                            <select id="serviceTimeRange" class="export-select">
                                <option value="past-month" selected>Past Month</option>
                                <option value="last-3-months">Last 3 Months</option>
                                <option value="this-year">This Year</option>
                                <option value="all-time">All Time</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- KPI Summary Section -->
                <div class="export-widget-section">
                    <label class="export-option">
                        <input type="checkbox" name="exportItem" value="kpis" checked>
                        <div>
                            <strong>📈 KPI Summary</strong>
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Key performance indicators and metrics</div>
                        </div>
                    </label>
                </div>

                <!-- Quick Stats Section -->
                <div class="export-widget-section">
                    <label class="export-option">
                        <input type="checkbox" name="exportItem" value="quick-stats">
                        <div>
                            <strong>⚡ Quick Stats</strong>
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Summary statistics and totals</div>
                        </div>
                    </label>
                </div>
            </div>

            <!-- Export Actions -->
            <div style="margin-top: var(--spacing-lg); padding-top: var(--spacing-md); border-top: 1px solid var(--border-color);">
                <div style="display: flex; gap: var(--spacing-sm); flex-wrap: wrap;">
                    <button class="btn btn-primary" onclick="generateEnhancedPDF()">
                        📄 Generate PDF Report
                    </button>
                    <button class="btn btn-secondary" onclick="printDashboard()">
                        🖨️ Print Dashboard
                    </button>
                    <button class="btn btn-secondary" onclick="exportJSON()">
                        💾 Export JSON Data
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Widget Modal -->
    <div class="modal" id="addWidgetModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Add Widget</h2>
                <button class="close-btn" onclick="closeModal('addWidgetModal')">&times;</button>
            </div>
            <div class="export-options">
                <div class="export-option" onclick="addWidget('revenue-chart')">
                    <span>📊</span>
                    <div>
                        <strong>Revenue Chart</strong>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Time-series revenue analysis with expand/collapse</div>
                    </div>
                </div>
                <div class="export-option" onclick="addWidget('service-distribution')">
                    <span>🥧</span>
                    <div>
                        <strong>Service Distribution</strong>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Pie chart of service popularity</div>
                    </div>
                </div>
                <div class="export-option" onclick="addWidget('bookings')">
                    <span>📊</span>
                    <div>
                        <strong>Bookings</strong>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Unified booking table with expand/collapse</div>
                    </div>
                </div>
                <div class="export-option" onclick="addWidget('calendar')">
                    <span>📅</span>
                    <div>
                        <strong>Calendar View</strong>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Bookings by date</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Layout Name Modal -->
    <div class="modal" id="customLayoutModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Create Custom Layout</h2>
                <button class="close-btn" onclick="closeModal('customLayoutModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="layoutName">Layout Name:</label>
                    <input type="text" id="layoutName" class="form-input" placeholder="Enter layout name..." maxlength="20" onkeypress="handleLayoutNameKeypress(event)">
                    <div class="form-help">Choose a unique name for your custom dashboard layout</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('customLayoutModal')">Cancel</button>
                <button class="btn btn-primary" onclick="createCustomLayout()">Create Layout</button>
            </div>
        </div>
    </div>

    <!-- Data Access Password Modal -->
    <div class="modal" id="dataAccessModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">🔓 Enter Restricted Mode Password</h2>
                <button class="close-btn" onclick="closeModal('dataAccessModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="dataAccessPassword">Password:</label>
                    <input type="password" id="dataAccessPassword" class="form-input" placeholder="Enter password to unlock sensitive data..." autofocus>
                    <div class="form-help">Enter the correct password to view sensitive business data</div>
                    <div id="passwordError" class="error-message" style="display: none; color: var(--danger-color); margin-top: var(--spacing-xs);">
                        Incorrect password. Please try again.
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('dataAccessModal')">Cancel</button>
                <button class="btn btn-primary" onclick="verifyRestrictedModePassword()">Unlock Data</button>
            </div>
        </div>
    </div>

    <!-- Booking Details Modal -->
    <div class="modal" id="bookingDetailsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Booking Details</h2>
                <button class="close-btn" onclick="closeModal('bookingDetailsModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="booking-details">
                    <div class="detail-section">
                        <h3>Customer Information</h3>
                        <div class="detail-grid">
                            <div class="detail-item">
                                <label>Name:</label>
                                <span id="booking-customer-name">-</span>
                            </div>
                            <div class="detail-item">
                                <label>Phone:</label>
                                <span id="booking-phone">-</span>
                            </div>
                            <div class="detail-item">
                                <label>Email:</label>
                                <span id="booking-email">-</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="detail-section">
                        <h3>Service Details</h3>
                        <div class="detail-grid">
                            <div class="detail-item">
                                <label>Date:</label>
                                <span id="booking-date">-</span>
                            </div>
                            <div class="detail-item">
                                <label>Time:</label>
                                <span id="booking-time">-</span>
                            </div>
                            <div class="detail-item">
                                <label>Status:</label>
                                <span id="booking-status" class="status-badge">-</span>
                            </div>
                            <div class="detail-item">
                                <label>Car Details:</label>
                                <span id="booking-car">-</span>
                            </div>
                        </div>
                        <div class="detail-item full-width">
                            <label>Services:</label>
                            <div id="booking-services" class="services-list"></div>
                        </div>
                        <div class="detail-item full-width">
                            <label>Notes:</label>
                            <span id="booking-notes">-</span>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <div class="modal-actions">
                    <button class="btn btn-danger" id="cancelBookingBtn" onclick="updateBookingStatus('cancelled')">
                        Cancel Booking
                    </button>
                    <button class="btn btn-warning" id="pendingBookingBtn" onclick="updateBookingStatus('pending')">
                        Mark Pending
                    </button>
                    <button class="btn btn-success" id="confirmBookingBtn" onclick="updateBookingStatus('confirmed')">
                        Confirm Booking
                    </button>
                </div>
                <button class="btn btn-secondary" onclick="closeModal('bookingDetailsModal')">Close</button>
            </div>
        </div>
    </div>
    <script>
        // Global state
        let dashboardData = null;
        let filteredData = null;
        let currentTheme = 'light';
        let currentView = 'full';
        
        // Chart.js instances - store references to properly destroy/update charts
        let revenueChartInstance = null;
        let servicesChartInstance = null;
        let timelineChartInstance = null;
        
        // Restricted Mode system state
        let restrictedMode = true; // Default to restricted state
        const DATA_ACCESS_PASSWORD = '111'; // Hardcoded password (change later)
        
        // Global restricted mode event listeners
        const restrictedModeListeners = [];
        
        // Function to notify all listeners of restricted mode changes
        function notifyRestrictedModeChange(isRestricted) {
            restrictedModeListeners.forEach(listener => {
                try {
                    listener(isRestricted);
                } catch (error) {
                    console.error('Error in restricted mode listener:', error);
                }
            });
        }
        
        // Function to register a listener for restricted mode changes
        function addRestrictedModeListener(callback) {
            restrictedModeListeners.push(callback);
        }
        
        // Sensitive data configuration - easily modifiable
        const SENSITIVE_CONFIG = {
            widgets: {
                // Widgets to completely hide with lock overlay
            completelyHidden: ['widget-revenue'],
                // Widgets to partially hide (keep title, hide content)
                partiallyHidden: ['widget-stats']
            },
            kpiFields: {
                // KPI cards to hide values
                hideValues: ['total-revenue', 'total-bookings', 'avg-booking-value', 'popular-service']
            },
            bookingFields: {
                // Fields to hide in booking tables
                hideFields: ['email', 'payment', 'phone']
            }
        };
        let widgets = [];
        let autoSaveEnabled = true;
        let autoSaveInterval = null;
        let lastSaveTime = null;
        let customLayouts = [];
        let currentCustomLayout = null;
        let widgetObserver = null;

        // Initialize
        // Custom Layout Management
        function loadCustomLayouts() {
            const saved = localStorage.getItem('customLayouts');
            if (saved) {
                try {
                    customLayouts = JSON.parse(saved);
                } catch (error) {
                    console.error('Error loading custom layouts:', error);
                    customLayouts = [];
                }
            }
            renderCustomLayoutButtons();
        }

        function saveCustomLayouts() {
            localStorage.setItem('customLayouts', JSON.stringify(customLayouts));
        }

        function handleLayoutNameKeypress(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default form submission
                createCustomLayout();
            }
        }
        
        function createCustomLayout() {
            const layoutName = document.getElementById('layoutName').value.trim();
            
            if (!layoutName) {
                showToast('Please enter a layout name', 'error');
                document.getElementById('layoutName').focus();
                return;
            }
            
            // Check if name already exists
            if (customLayouts.some(layout => layout.name.toLowerCase() === layoutName.toLowerCase())) {
                showToast('Layout name already exists', 'error');
                return;
            }
            
            // Create new custom layout
            const newLayout = {
                id: Date.now().toString(),
                name: layoutName,
                widgets: [],
                createdAt: new Date().toISOString()
            };
            
            customLayouts.push(newLayout);
            saveCustomLayouts();
            
            // Switch to custom view and activate this layout
            currentView = 'custom';
            currentCustomLayout = newLayout.id;
            
            // Update view buttons
            document.querySelectorAll('.view-mode-btn').forEach(b => b.classList.remove('active'));
            
            renderCustomLayoutButtons();
            // Activate the new layout button
            setTimeout(() => {
                document.querySelector(`[data-layout-id="${newLayout.id}"]`).classList.add('active');
            }, 100);
            
            renderDashboard();
            updateMobileUI(); // Update mobile UI when switching to custom layout
            
            // Setup widget observer for the new custom layout
            setTimeout(() => {
                setupWidgetObserver();
            }, 100);
            
            closeModal('customLayoutModal');
            document.getElementById('layoutName').value = '';
            
            showToast(`Custom layout "${layoutName}" created!`, 'success');
        }

        function renderCustomLayoutButtons() {
            const viewModes = document.querySelector('.view-modes');
            const fullViewBtn = document.querySelector('[data-view="full"]');
            const customBtn = document.getElementById('customBtn');
            
            // Remove existing custom layout buttons
            document.querySelectorAll('.custom-layout-btn').forEach(btn => btn.remove());
            
            // Add custom layout buttons right after Full View
            customLayouts.forEach(layout => {
                const btn = document.createElement('button');
                btn.className = 'view-mode-btn custom-layout-btn';
                btn.setAttribute('data-layout-id', layout.id);
                btn.innerHTML = `
                    ${layout.name}
                    <div class="layout-actions">
                        <button class="layout-action-btn" onclick="deleteCustomLayout('${layout.id}', event)" title="Delete">×</button>
                    </div>
                `;
                
                btn.addEventListener('click', (e) => {
                    if (e.target.classList.contains('layout-action-btn')) return;
                    
                    // Clean up previous layout before switching
                    cleanupLayout();
                    
                    document.querySelectorAll('.view-mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentView = 'custom';
                    currentCustomLayout = layout.id;
                    
                    console.log(`Switching to custom layout: ${layout.name} (ID: ${layout.id})`);
                    
                    // Add a small delay to ensure cleanup is complete before rendering
                    setTimeout(() => {
                        renderDashboard();
                        updateMobileUI(); // Update mobile UI when switching layouts
                        
                        // Setup widget observer for this custom layout after rendering
                        setTimeout(() => {
                            setupWidgetObserver();
                        }, 100);
                    }, 50);
                    
                    triggerAutoSave();
                });
                
                // Insert after Full View button
                viewModes.insertBefore(btn, customBtn);
            });
            
            // Sync mobile view buttons if the function exists
            if (typeof syncMobileViewButtons === 'function') {
                syncMobileViewButtons();
            }
        }

        function deleteCustomLayout(layoutId, event) {
            event.stopPropagation();
            
            const layout = customLayouts.find(l => l.id === layoutId);
            if (!layout) return;
            
            if (confirm(`Are you sure you want to delete the layout "${layout.name}"?`)) {
                customLayouts = customLayouts.filter(l => l.id !== layoutId);
                saveCustomLayouts();
                
                // If this was the active layout, switch to full view
                if (currentCustomLayout === layoutId) {
                    currentView = 'full';
                    currentCustomLayout = null;
                    document.querySelectorAll('.view-mode-btn').forEach(b => b.classList.remove('active'));
                    document.querySelector('[data-view="full"]').classList.add('active');
                    renderDashboard();
                    updateMobileUI(); // Update mobile UI when deleting layout
                }
                
                renderCustomLayoutButtons();
                showToast(`Layout "${layout.name}" deleted`, 'success');
            }
        }

        function getCurrentCustomLayout() {
            if (!currentCustomLayout) return null;
            return customLayouts.find(layout => layout.id === currentCustomLayout);
        }

        function cleanupLayout() {
            // Disconnect widget observer to prevent cross-layout contamination
            if (widgetObserver) {
                widgetObserver.disconnect();
                widgetObserver = null;
                console.log('Widget observer disconnected for layout cleanup');
            }
            
            // Clear any pending timeouts related to widgets
            if (window.widgetSaveTimeout) {
                clearTimeout(window.widgetSaveTimeout);
                window.widgetSaveTimeout = null;
            }
            
            // Clear any pending auto-save timeouts
            if (window.autoSaveTimeout) {
                clearTimeout(window.autoSaveTimeout);
                window.autoSaveTimeout = null;
            }
            
            // Clear the grid completely to ensure no widget remnants
            const grid = document.getElementById('dashboardGrid');
            if (grid) {
                // Store the number of widgets before cleanup
                const widgetCount = grid.querySelectorAll('.widget').length;
                
                // Clear all content to ensure clean slate
                grid.innerHTML = '';
                
                console.log(`Cleaned up ${widgetCount} widgets for layout isolation`);
            }
        }

        function saveCurrentCustomLayout() {
            if (!currentCustomLayout) return;
            
            const layout = getCurrentCustomLayout();
            if (!layout) return;
            
            // Get current widgets and ensure they have proper IDs
            const currentWidgets = [];
            document.querySelectorAll('.widget').forEach(widget => {
                // Only save widgets that belong to the current layout
                if (!widget.id.includes(`layout-${currentCustomLayout}-`) && 
                    widget.id.includes('layout-')) {
                    console.log(`Skipping widget ${widget.id} - belongs to different layout`);
                    return; // Skip this widget
                }
                // Ensure widget has a proper ID
                if (!widget.id || !widget.id.startsWith('widget-')) {
                    const layoutPrefix = currentCustomLayout ? `layout-${currentCustomLayout}-` : '';
                    const widgetType = getWidgetType(widget);
                    widget.id = `widget-${layoutPrefix}${widgetType}-${Date.now()}`;
                }
                
                const widgetData = {
                    id: widget.id,
                    classes: widget.className,
                    type: getWidgetType(widget),
                    position: getWidgetPosition(widget),
                    size: getWidgetSize(widget),
                    customizations: getWidgetCustomizations(widget)
                };
                
                // Extract custom type and timestamp from ID
                if (widget.id.includes('widget-') && widget.id.includes('-')) {
                    const parts = widget.id.split('-');
                    if (parts.length >= 3) {
                        widgetData.customType = parts[1] + '-' + parts[2];
                        widgetData.timestamp = parts[parts.length - 1] || Date.now();
                    }
                }
                
                currentWidgets.push(widgetData);
            });
            
            layout.widgets = currentWidgets;
            layout.updatedAt = new Date().toISOString();
            
            saveCustomLayouts();
            console.log(`Custom layout "${layout.name}" (${currentCustomLayout}) saved with ${currentWidgets.length} widgets`);
            
            // Log widget IDs for debugging
            currentWidgets.forEach(widget => {
                console.log(`  - Widget: ${widget.id} (${widget.type})`);
            });
        }

        function setupWidgetObserver() {
            // Disconnect existing observer to prevent cross-layout contamination
            if (widgetObserver) {
                widgetObserver.disconnect();
                widgetObserver = null;
            }
            
            const grid = document.getElementById('dashboardGrid');
            if (!grid) return;
            
            // Create new observer
            widgetObserver = new MutationObserver((mutations) => {
                if (currentView === 'custom' && currentCustomLayout) {
                    let shouldSave = false;
                    
                    mutations.forEach((mutation) => {
                        // Check if widgets were added, removed, or moved
                        if (mutation.type === 'childList') {
                            // Only save if the changes are to widgets that belong to current layout
                            mutation.addedNodes.forEach(node => {
                                if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains('widget')) {
                                    // Check if widget belongs to current layout
                                    if (node.id.includes(`layout-${currentCustomLayout}-`) || 
                                        !node.id.includes('layout-')) {
                                        shouldSave = true;
                                    }
                                }
                            });
                            
                            mutation.removedNodes.forEach(node => {
                                if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains('widget')) {
                                    // Check if widget belonged to current layout
                                    if (node.id.includes(`layout-${currentCustomLayout}-`) || 
                                        !node.id.includes('layout-')) {
                                        shouldSave = true;
                                    }
                                }
                            });
                        }
                        // Check if widget attributes changed (like position, size)
                        else if (mutation.type === 'attributes') {
                            const target = mutation.target;
                            if (target.classList.contains('widget') && 
                                (mutation.attributeName === 'class' || mutation.attributeName === 'style')) {
                                // Only save if widget belongs to current layout
                                if (target.id.includes(`layout-${currentCustomLayout}-`) || 
                                    !target.id.includes('layout-')) {
                                    shouldSave = true;
                                }
                            }
                        }
                    });
                    
                    if (shouldSave) {
                        // Debounce the save operation
                        clearTimeout(window.widgetSaveTimeout);
                        window.widgetSaveTimeout = setTimeout(() => {
                            saveCurrentCustomLayout();
                        }, 500);
                    }
                }
            });
            
            // Start observing
            widgetObserver.observe(grid, {
                childList: true,
                attributes: true,
                attributeFilter: ['class', 'style'],
                subtree: true
            });
        }

        function restoreActiveState() {
            // Clear all active states first
            document.querySelectorAll('.view-mode-btn').forEach(b => b.classList.remove('active'));
            
            // Restore the correct active state based on current view and custom layout
            if (currentView === 'custom' && currentCustomLayout) {
                // Find and activate the correct custom layout button
                const customBtn = document.querySelector(`[data-layout-id="${currentCustomLayout}"]`);
                if (customBtn) {
                    customBtn.classList.add('active');
                } else {
                    // If custom layout button not found, fall back to full view
                    currentView = 'full';
                    currentCustomLayout = null;
                    document.querySelector('[data-view="full"]').classList.add('active');
                }
            } else {
                // Activate the standard view button
                const standardBtn = document.querySelector(`[data-view="${currentView}"]`);
                if (standardBtn) {
                    standardBtn.classList.add('active');
                } else {
                    // Fallback to full view if something is wrong
                    currentView = 'full';
                    document.querySelector('[data-view="full"]').classList.add('active');
                }
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            await loadData();
            initializeTheme();
            initializeEventListeners();
            loadCustomLayouts();
            initializeAutoSave();
            initializeToolbarState();
            initializeMobileUI();
            initializeRestrictedMode();
            
            // Automatically load saved layout on startup BEFORE rendering
            await loadLayoutAutomatically();
            
            // Validate the current view - if custom layout doesn't exist, fallback to full
            if (currentView === 'custom') {
                const layout = getCurrentCustomLayout();
                if (!layout) {
                    console.warn('Custom layout not found, falling back to full view');
                    currentView = 'full';
                    currentCustomLayout = null;
                }
            }
            
            // Restore the correct active state after loading layouts
            restoreActiveState();
            
            // Ensure data is fully processed before rendering
            if (dashboardData && dashboardData.bookings) {
                console.log('Data is ready, rendering dashboard...');
                console.log('Current view:', currentView, 'Custom layout ID:', currentCustomLayout);
                renderDashboard();
                
                // Initialize drag-and-drop after rendering
                setTimeout(() => {
                    initializeDraggableWidgets();
                }, 100);
                
                // Show success message without auto-applying filters
                setTimeout(() => {
                    console.log('Dashboard loaded successfully');
                    showToast('Dashboard loaded', 'success');
                }, 300);
            } else {
                console.warn('Data not ready, retrying in 200ms...');
                setTimeout(() => {
                    if (dashboardData && dashboardData.bookings) {
                        console.log('Data is ready after retry, rendering dashboard...');
                        renderDashboard();
                        setTimeout(() => {
                            initializeDraggableWidgets();
                        }, 100);
                    } else {
                        console.error('Data still not ready after retry');
                        showToast('Error: Data not loaded properly', 'error');
                    }
                }, 200);
            }
            
            // Setup widget observer for real-time saving
            setupWidgetObserver();
            
            // Trigger an immediate save after everything is loaded
            setTimeout(() => {
                console.log('Triggering initial save after load');
                triggerAutoSave();
            }, 2000);
        });

        // Load data from JSON
        async function loadData() {
            try {
                const response = await fetch('booking-output.json');
                dashboardData = await response.json();
                filteredData = { ...dashboardData };
                console.log('Data loaded successfully:', dashboardData);
                
                // Load any saved booking data from localStorage
                loadBookingDataFromStorage();
            } catch (error) {
                console.error('Error loading data:', error);
                showToast('Error loading data. Please check booking-output.json', 'error');
            }
        }

        // Theme Management
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            setTheme(savedTheme, true); // Skip auto-save during initialization
        }

        function setTheme(theme, skipAutoSave = false) {
            currentTheme = theme;
            document.documentElement.setAttribute('data-theme', theme);
            document.getElementById('themeIcon').textContent = theme === 'dark' ? '☀️' : '🌙';
            localStorage.setItem('theme', theme);
            if (!skipAutoSave) {
                triggerAutoSave(); // Auto-save when theme changes
            }
        }

        function toggleTheme() {
            setTheme(currentTheme === 'light' ? 'dark' : 'light');
        }

        // Event Listeners
        function initializeEventListeners() {
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            document.getElementById('exportBtn').addEventListener('click', () => openModal('exportModal'));
            document.getElementById('applyFilters').addEventListener('click', applyFilters);
            document.getElementById('resetFilters').addEventListener('click', resetFilters);
            
            // Enhanced export modal event listeners
            const bookingsTimeRange = document.getElementById('bookingsTimeRange');
            if (bookingsTimeRange) {
                bookingsTimeRange.addEventListener('change', handleBookingsTimeRangeChange);
            }
            
            // Mobile menu functionality
            const mobileMenuBtn = document.getElementById('mobileMenuBtn');
            const mobileNav = document.getElementById('mobileNav');
            const mobileMenuIcon = document.getElementById('mobileMenuIcon');
            
            // Close mobile menu function
            function closeMobileMenu() {
                if (mobileNav) {
                    mobileNav.classList.remove('active');
                    if (mobileMenuIcon) {
                        mobileMenuIcon.textContent = '☰';
                    }
                }
            }
            
            // Make it global so onclick can access it
            window.closeMobileMenu = closeMobileMenu;
            
            if (mobileMenuBtn && mobileNav) {
                mobileMenuBtn.addEventListener('click', () => {
                    mobileNav.classList.toggle('active');
                    mobileMenuIcon.textContent = mobileNav.classList.contains('active') ? '✕' : '☰';
                });
                
                // Close mobile menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!mobileMenuBtn.contains(e.target) && !mobileNav.contains(e.target)) {
                        closeMobileMenu();
                    }
                });
                
                // Close mobile menu when window is resized to desktop
                window.addEventListener('resize', () => {
                    if (window.innerWidth > 768 && mobileNav.classList.contains('active')) {
                        closeMobileMenu();
                    }
                });
            }
            
            // Mobile button event listeners
            const mobileButtons = [
                { id: 'exportBtnMobile', action: () => openModal('exportModal') },
                { id: 'themeToggleMobile', action: toggleTheme }
            ];
            
            mobileButtons.forEach(({ id, action }) => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.addEventListener('click', () => {
                        action();
                        closeMobileMenu();
                    });
                }
            });
            
            // Sync mobile filters with desktop filters
            function syncFilters(fromMobile = false) {
                const timePeriodDesktop = document.getElementById('timePeriodFilter');
                const timePeriodMobile = document.getElementById('timePeriodFilterMobile');
                const statusDesktop = document.getElementById('statusFilter');
                const statusMobile = document.getElementById('statusFilterMobile');
                
                if (fromMobile) {
                    if (timePeriodDesktop && timePeriodMobile) timePeriodDesktop.value = timePeriodMobile.value;
                    if (statusDesktop && statusMobile) statusDesktop.value = statusMobile.value;
                } else {
                    if (timePeriodDesktop && timePeriodMobile) timePeriodMobile.value = timePeriodDesktop.value;
                    if (statusDesktop && statusMobile) statusMobile.value = statusDesktop.value;
                }
            }
            
            // Mobile filter event listeners
            const applyFiltersMobile = document.getElementById('applyFiltersMobile');
            const resetFiltersMobile = document.getElementById('resetFiltersMobile');
            const timePeriodFilterMobile = document.getElementById('timePeriodFilterMobile');
            const statusFilterMobile = document.getElementById('statusFilterMobile');
            
            if (applyFiltersMobile) {
                applyFiltersMobile.addEventListener('click', () => {
                    syncFilters(true);
                    applyFilters();
                    closeMobileMenu();
                    showToast('Filters applied', 'success');
                });
            }
            
            if (resetFiltersMobile) {
                resetFiltersMobile.addEventListener('click', () => {
                    if (timePeriodFilterMobile) timePeriodFilterMobile.value = '';
                    if (statusFilterMobile) statusFilterMobile.value = '';
                    syncFilters(true);
                    resetFilters();
                    closeMobileMenu();
                    showToast('Filters reset', 'info');
                });
            }
            
            // Sync mobile view buttons with desktop
            function syncMobileViewButtons() {
                const desktopViewBtns = document.querySelectorAll('.toolbar .view-mode-btn');
                const mobileViewContainer = document.getElementById('mobileViewModes');
                
                if (!mobileViewContainer) return;
                
                // Clear mobile container
                mobileViewContainer.innerHTML = '';
                
                // Rebuild mobile view buttons with proper event handling
                Array.from(desktopViewBtns).forEach(desktopBtn => {
                    const mobileBtn = document.createElement('button');
                    mobileBtn.className = desktopBtn.className;
                    mobileBtn.textContent = desktopBtn.textContent;
                    mobileBtn.innerHTML = desktopBtn.innerHTML;
                    
                    // Copy data attributes
                    if (desktopBtn.dataset.view) {
                        mobileBtn.dataset.view = desktopBtn.dataset.view;
                    }
                    if (desktopBtn.dataset.layoutId) {
                        mobileBtn.dataset.layoutId = desktopBtn.dataset.layoutId;
                    }
                    
                    // Add click handler
                    mobileBtn.addEventListener('click', (e) => {
                        // Trigger the desktop button's click
                        desktopBtn.click();
                        // Close mobile menu
                        closeMobileMenu();
                    });
                    
                    mobileViewContainer.appendChild(mobileBtn);
                });
            }
            
            // Make it global so renderCustomLayoutButtons can access it
            window.syncMobileViewButtons = syncMobileViewButtons;
            
            // Initial sync (with delay to ensure DOM is ready)
            setTimeout(() => {
                syncMobileViewButtons();
                syncFilters(false);
            }, 100);
            
            // View mode buttons
            document.querySelectorAll('.view-mode-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // Handle custom button specially - always prompt for layout name
                    if (e.target.dataset.view === 'custom') {
                        e.preventDefault();
                        openModal('customLayoutModal');
                        return;
                    } else {
                        // Clean up custom layout if switching away from custom view
                        if (currentView === 'custom') {
                            cleanupLayout();
                        }
                        
                        // Update current view
                        currentView = e.target.dataset.view;
                        currentCustomLayout = null; // Clear custom layout when switching to standard views
                    }
                    
                    document.querySelectorAll('.view-mode-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    renderDashboard();
                    updateMobileUI(); // Update mobile UI when view changes
                    triggerAutoSave(); // Auto-save when view changes
                });
            });

            // Real-time auto-save triggers for all changes (but only for standard views)
            document.addEventListener('change', (e) => {
                // Only trigger auto-save for standard views, not custom layouts
                if (currentView !== 'custom') {
                    triggerAutoSave();
                }
            });
            document.addEventListener('input', debounce((e) => {
                // Only trigger auto-save for standard views, not custom layouts
                if (currentView !== 'custom') {
                    triggerAutoSave();
                }
            }, 500));
            document.addEventListener('click', debounce((e) => {
                // Only trigger auto-save for standard views, not custom layouts
                if (currentView !== 'custom') {
                    triggerAutoSave();
                }
            }, 1000));
            
            // Save before page unload
            window.addEventListener('beforeunload', () => {
                if (autoSaveEnabled) {
                    saveLayoutSilently();
                }
            });
            
            // Auto-save on window focus (in case user switched tabs)
            window.addEventListener('focus', () => {
                if (autoSaveEnabled) {
                    // Only trigger auto-save for standard views, not custom layouts
                    if (currentView !== 'custom') {
                        triggerAutoSave();
                    }
                }
            });
            
            // Register KPI widgets as listeners for restricted mode changes
            addRestrictedModeListener((isRestricted) => {
                // Re-render KPI widgets when restricted mode changes
                const kpis = calculateKPIs(filteredData);
                const currentFilters = getCurrentFilters();
                const improvements = calculateImprovements(filteredData, currentFilters);
                renderKPIs(kpis, improvements, currentFilters);
                console.log('KPI widgets updated due to restricted mode change:', isRestricted);
            });
        }

        // Auto-save functionality
        function initializeAutoSave() {
            if (autoSaveEnabled) {
                // Auto-save every 10 seconds for more frequent saves
                autoSaveInterval = setInterval(() => {
                    autoSave();
                }, 10000);
                
                // Set initial status
                updateAutoSaveIndicator('saved');
                
                console.log('Real-time auto-save enabled - saving every 10 seconds');
            } else {
                updateAutoSaveIndicator('disabled');
            }
        }

        function autoSave() {
            if (autoSaveEnabled) {
                try {
                    console.log('=== AUTO-SAVE TRIGGERED ===');
                    updateAutoSaveIndicator('saving');
                    
                    // Skip auto-save for custom layouts - they have their own save mechanism
                    if (currentView === 'custom' && currentCustomLayout) {
                        console.log('Skipping auto-save for custom layout - using custom save mechanism');
                        updateAutoSaveIndicator('saved');
                        return;
                    }
                    
                    const layout = createCurrentLayout();
                    console.log('Saving layout:', layout);
                    saveToLocalStorage(layout);
                    saveToIndexedDB(layout);
                    lastSaveTime = new Date().toISOString();
                    updateAutoSaveIndicator('saved');
                    console.log('Auto-saved layout at', lastSaveTime);
                } catch (error) {
                    console.error('Auto-save failed:', error);
                    updateAutoSaveIndicator('error');
                }
            }
        }

        function updateAutoSaveIndicator(status) {
            const indicator = document.getElementById('autoSaveIndicator');
            const icon = document.getElementById('autoSaveIcon');
            
            if (!indicator) return;
            
            // Remove all status classes
            indicator.classList.remove('saving', 'saved', 'error', 'disabled');
            
            switch(status) {
                case 'saving':
                    indicator.classList.add('saving');
                    icon.textContent = '💾';
                    indicator.title = 'Auto-saving...';
                    break;
                case 'saved':
                    indicator.classList.add('saved');
                    icon.textContent = '✅';
                    indicator.title = `Last saved: ${lastSaveTime ? new Date(lastSaveTime).toLocaleTimeString() : 'Never'}`;
                    break;
                case 'error':
                    indicator.classList.add('error');
                    icon.textContent = '❌';
                    indicator.title = 'Auto-save failed';
                    break;
                case 'disabled':
                    indicator.classList.add('disabled');
                    icon.textContent = '💾';
                    indicator.title = 'Auto-save disabled';
                    break;
            }
        }

        function triggerAutoSave() {
            if (autoSaveEnabled) {
                // Debounced auto-save for immediate changes (faster response)
                clearTimeout(window.autoSaveTimeout);
                window.autoSaveTimeout = setTimeout(() => {
                    // Save current custom layout if we're in custom view
                    if (currentView === 'custom' && currentCustomLayout) {
                        saveCurrentCustomLayout();
                    } else {
                        // Only save standard layout for non-custom views
                        autoSave();
                    }
                }, 1000);
            }
        }

        // Silent save without UI feedback (for page unload)
        function saveLayoutSilently() {
            if (autoSaveEnabled) {
                try {
                    // Save current custom layout if we're in custom view
                    if (currentView === 'custom' && currentCustomLayout) {
                        saveCurrentCustomLayout();
                        console.log('Custom layout saved silently');
                    } else {
                        // Save standard layout for non-custom views
                        const layout = createCurrentLayout();
                        
                        // Migrate layout if needed
                        const migratedLayout = migrateLayout(layout);
                        
                        // Save to storage silently
                        saveToLocalStorage(migratedLayout);
                        saveToIndexedDB(migratedLayout);
                        
                        console.log('Standard layout saved silently');
                    }
                } catch (error) {
                    console.error('Silent save failed:', error);
                }
            }
        }

        function createCurrentLayout() {
            const layout = {
                theme: currentTheme,
                view: currentView,
                customLayoutId: currentCustomLayout, // Include current custom layout ID
                widgets: [],
                filters: getCurrentFilters(),
                kpiSettings: getKPISettings(),
                timestamp: new Date().toISOString(),
                version: '2.0',
                metadata: {
                    userAgent: navigator.userAgent,
                    screenResolution: `${screen.width}x${screen.height}`,
                    savedBy: 'Venus Dashboard V0.9beta',
                    autoSaved: true
                }
            };
            
            // For custom layouts, only capture widgets that belong to the current layout
            if (currentView === 'custom' && currentCustomLayout) {
                // Don't capture widgets here - custom layouts are saved separately
                console.log('Skipping widget capture in createCurrentLayout for custom view');
                return layout;
            }
            
            // Capture all widgets on the page (for standard views only)
            document.querySelectorAll('.widget').forEach(widget => {
                const widgetData = {
                    id: widget.id,
                    classes: widget.className,
                    type: getWidgetType(widget),
                    position: getWidgetPosition(widget),
                    size: getWidgetSize(widget),
                    customizations: getWidgetCustomizations(widget)
                };
                
                // For custom widgets, save additional data
                if (widget.id.includes('widget-') && widget.id.includes('-')) {
                    const parts = widget.id.split('-');
                    if (parts.length >= 3) {
                        widgetData.customType = parts[1] + '-' + parts[2];
                        widgetData.timestamp = parts[3] || Date.now();
                    }
                }
                
                layout.widgets.push(widgetData);
            });
            
            console.log('Creating layout with', layout.widgets.length, 'widgets:', layout);
            return layout;
        }

        // Debounce utility function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Modal Management
        function openModal(modalId) {
            document.getElementById(modalId).classList.add('active');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }
        // Restricted Mode System Functions
        function toggleRestrictedMode() {
            if (restrictedMode) {
                // Show password modal to unlock
                openModal('dataAccessModal');
                document.getElementById('dataAccessPassword').focus();
            } else {
                // Enable restricted mode immediately
                enableRestrictedMode();
                updateRestrictedModeButtonState();
                showToast('Restricted Mode enabled', 'info');
            }
        }

        function verifyRestrictedModePassword() {
            const password = document.getElementById('dataAccessPassword').value;
            const errorDiv = document.getElementById('passwordError');
            
            if (password === DATA_ACCESS_PASSWORD) {
                restrictedMode = false;
                closeModal('dataAccessModal');
                disableRestrictedMode();
                updateRestrictedModeButtonState();
                showToast('Restricted Mode disabled - All data visible', 'success');
                document.getElementById('dataAccessPassword').value = '';
                errorDiv.style.display = 'none';
            } else {
                errorDiv.style.display = 'block';
                document.getElementById('dataAccessPassword').value = '';
                document.getElementById('dataAccessPassword').focus();
            }
        }

        function enableRestrictedMode() {
            restrictedMode = true;
            
            // Hide completely sensitive widgets
            SENSITIVE_CONFIG.widgets.completelyHidden.forEach(widgetId => {
                const widget = document.getElementById(widgetId);
                if (widget) {
                    hideWidgetCompletely(widget);
                }
            });
            
            // Hide partially sensitive widgets
            SENSITIVE_CONFIG.widgets.partiallyHidden.forEach(widgetId => {
                const widget = document.getElementById(widgetId);
                if (widget) {
                    hideWidgetPartially(widget);
                }
            });
            
            // Hide any revenue widgets by title across all layouts (custom and standard)
            document.querySelectorAll('.widget .widget-title').forEach(titleEl => {
                if (/revenue/i.test(titleEl.textContent || '')) {
                    const targetWidget = titleEl.closest('.widget');
                    if (targetWidget) {
                        hideWidgetCompletely(targetWidget);
                    }
                }
            });
            
            // Hide KPI values
            hideKPIValues();
            
            // Refresh KPI cards to show masked values immediately
            const kpis = calculateKPIs(filteredData);
            const currentFilters = getCurrentFilters();
            const improvements = calculateImprovements(filteredData, currentFilters);
            renderKPIs(kpis, improvements, currentFilters);
            
            // Hide sensitive booking data
            hideBookingSensitiveData();
            
            // Debug logging for restricted mode toggle
            console.log('Restricted Mode enabled - KPI widgets masked');
            
            // Notify all listeners of the restricted mode change
            notifyRestrictedModeChange(true);
        }

        function disableRestrictedMode() {
            restrictedMode = false;
            
            // Show all widgets
            document.querySelectorAll('.restricted-widget').forEach(widget => {
                widget.classList.remove('restricted-widget');
            });
            
            document.querySelectorAll('.restricted-overlay').forEach(overlay => {
                overlay.remove();
            });
            
            // Restore any widget contents that were hidden when locked
            document.querySelectorAll('.widget .widget-content, .widget .widget-body, .widget canvas, .widget .chart-container').forEach(element => {
                if (element.style.display === 'none') {
                    element.style.display = '';
                }
            });
            
            // Show KPI values
            showKPIValues();
            
            // Show sensitive booking data
            showBookingSensitiveData();
            
            // Refresh KPI cards immediately to show actual values
            const kpis = calculateKPIs(filteredData);
            const currentFilters = getCurrentFilters();
            const improvements = calculateImprovements(filteredData, currentFilters);
            renderKPIs(kpis, improvements, currentFilters);
            
            // Instead of rebuilding the entire dashboard, just refresh the data content
            // while preserving widget sizes and states
            refreshDataContent();
            
            // Debug logging for restricted mode toggle
            console.log('Restricted Mode disabled - KPI widgets refreshed');
            
            // Notify all listeners of the restricted mode change
            notifyRestrictedModeChange(false);
        }
        
        function hideWidgetCompletely(widget) {
            widget.classList.add('restricted-widget');
            
            // Create lock overlay
            const overlay = document.createElement('div');
            overlay.className = 'restricted-overlay';
            overlay.innerHTML = `
                <div class="restricted-overlay-inner">
                    <div class="restricted-overlay-icon">🔒</div>
                    <div class="restricted-overlay-text">Sensitive data hidden — enter password to view</div>
                </div>
            `;
            widget.appendChild(overlay);
        }

        function hideWidgetPartially(widget) {
            widget.classList.add('restricted-widget');
            
            // Hide sensitive content within widget
            const sensitiveElements = widget.querySelectorAll('.booking-email, .booking-payment, .booking-phone, .stat-value, .kpi-value');
            sensitiveElements.forEach(element => {
                element.classList.add('restricted-hidden');
                element.setAttribute('data-original-text', element.textContent);
                element.textContent = '••••';
            });
        }

        function hideKPIValues() {
            document.querySelectorAll('.kpi-value').forEach(element => {
                element.classList.add('restricted-hidden');
                element.setAttribute('data-original-text', element.textContent);
                element.textContent = '••••';
            });
            
            document.querySelectorAll('.kpi-trend span').forEach(element => {
                if (element.textContent.includes('%') || element.textContent.includes('from')) {
                    element.classList.add('restricted-hidden');
                    element.setAttribute('data-original-text', element.textContent);
                    element.textContent = 'Hidden';
                }
            });
        }

        function showKPIValues() {
            document.querySelectorAll('.kpi-value[data-original-text]').forEach(element => {
                    element.classList.remove('restricted-hidden');
                    element.textContent = element.getAttribute('data-original-text');
                    element.removeAttribute('data-original-text');
            });
            
            document.querySelectorAll('.kpi-trend span[data-original-text]').forEach(element => {
                element.classList.remove('restricted-hidden');
                element.textContent = element.getAttribute('data-original-text');
                element.removeAttribute('data-original-text');
            });
        }

        function hideBookingSensitiveData() {
            // Hide email fields
            document.querySelectorAll('.mobile-booking-customer-email, [style*="font-size: 0.85rem; color: var(--text-secondary)"]').forEach(element => {
                if (element.textContent.includes('@')) {
                    element.classList.add('restricted-hidden');
                element.setAttribute('data-original-text', element.textContent);
                    element.textContent = '••••••••@•••••••';
                }
            });
            
            // Hide payment amounts in table cells and mobile booking totals
            document.querySelectorAll('td strong, .mobile-booking-total').forEach(element => {
                const text = element.textContent || '';
                if (/\$/.test(text)) {
                    element.classList.add('restricted-hidden');
                    element.setAttribute('data-original-text', element.textContent);
                    element.textContent = '••••';
                }
            });
        }

        function showBookingSensitiveData() {
            // Show email fields
            document.querySelectorAll('.mobile-booking-customer-email[data-original-text]').forEach(element => {
                element.classList.remove('restricted-hidden');
                element.textContent = element.getAttribute('data-original-text');
                element.removeAttribute('data-original-text');
            });
            
            // Show payment amounts in table cells and mobile booking totals
            document.querySelectorAll('td strong[data-original-text], .mobile-booking-total[data-original-text]').forEach(element => {
                element.classList.remove('restricted-hidden');
                element.textContent = element.getAttribute('data-original-text');
                element.removeAttribute('data-original-text');
            });
        }

        function updateRestrictedModeButtonState() {
            const buttons = ['lockBtn', 'lockBtnMobile'];
            const icons = ['lockIcon', 'lockIconMobile'];
            
            buttons.forEach(buttonId => {
                const button = document.getElementById(buttonId);
                if (button) {
                    button.className = `btn btn-icon lock-btn ${restrictedMode ? 'locked' : 'unlocked'}`;
                }
            });
            
            icons.forEach(iconId => {
                const icon = document.getElementById(iconId);
                if (icon) {
                    icon.textContent = restrictedMode ? '🔒' : '🔓';
                }
            });
        }

        function initializeRestrictedMode() {
            // Initialize button states
            updateRestrictedModeButtonState();
            
            // Apply initial restricted state
            if (restrictedMode) {
                enableRestrictedMode();
            }
            
            // Add keyboard support for password modal
            document.getElementById('dataAccessPassword')?.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    verifyRestrictedModePassword();
                }
            });
        }

        // Calculate KPIs
        function calculateKPIs(data) {
            if (!data || !data.bookings) return {};

            const bookings = data.bookings;
            const services = data.settings.serviceTypes;

            // Calculate total revenue
            let totalRevenue = 0;
            bookings.forEach(booking => {
                booking.services.forEach(serviceId => {
                    if (services[serviceId]) {
                        totalRevenue += services[serviceId].price;
                    }
                });
            });

            // Calculate average booking value
            const avgBookingValue = bookings.length > 0 ? totalRevenue / bookings.length : 0;

            // Count confirmed bookings
            const confirmedBookings = bookings.filter(b => b.status === 'confirmed').length;

            // Most popular service
            const serviceCount = {};
            bookings.forEach(booking => {
                booking.services.forEach(serviceId => {
                    serviceCount[serviceId] = (serviceCount[serviceId] || 0) + 1;
                });
            });
            const popularService = Object.keys(serviceCount).reduce((a, b) => 
                serviceCount[a] > serviceCount[b] ? a : b
            );

            return {
                totalRevenue,
                totalBookings: bookings.length,
                confirmedBookings,
                avgBookingValue,
                popularService: services[popularService]?.name || 'N/A'
            };
        }

        // Calculate improvement values between current and previous periods
        function calculateImprovements(currentData, currentFilters) {
            if (!currentData || !currentData.bookings || !dashboardData) return {};

            const currentKPIs = calculateKPIs(currentData);
            const timePeriod = currentFilters.timePeriod;
            const status = currentFilters.status;

            // Get previous period data
            const previousData = getPreviousPeriodData(timePeriod, status);
            if (!previousData || !previousData.bookings || previousData.bookings.length === 0) {
                return {
                    totalRevenue: { value: 0, text: 'No previous data available.', color: 'neutral' },
                    totalBookings: { value: 0, text: 'No previous data available.', color: 'neutral' },
                    avgBookingValue: { value: 0, text: 'No previous data available.', color: 'neutral' },
                    confirmedBookings: { value: 0, text: 'No previous data available.', color: 'neutral' }
                };
            }

            const previousKPIs = calculateKPIs(previousData);
            const previousLabel = getPreviousPeriodLabel(timePeriod);

            // Calculate percentage improvements
            const improvements = {};

            // Total Revenue improvement
            if (previousKPIs.totalRevenue > 0) {
                const revenueChange = ((currentKPIs.totalRevenue - previousKPIs.totalRevenue) / previousKPIs.totalRevenue) * 100;
                improvements.totalRevenue = {
                    value: revenueChange,
                    text: formatImprovementText(revenueChange, previousLabel),
                    color: revenueChange >= 0 ? 'positive' : 'negative'
                };
            } else {
                improvements.totalRevenue = {
                    value: 0,
                    text: 'No previous data available.',
                    color: 'neutral'
                };
            }

            // Total Bookings improvement
            if (previousKPIs.totalBookings > 0) {
                const bookingsChange = ((currentKPIs.totalBookings - previousKPIs.totalBookings) / previousKPIs.totalBookings) * 100;
                improvements.totalBookings = {
                    value: bookingsChange,
                    text: formatImprovementText(bookingsChange, previousLabel),
                    color: bookingsChange >= 0 ? 'positive' : 'negative'
                };
            } else {
                improvements.totalBookings = {
                    value: 0,
                    text: 'No previous data available.',
                    color: 'neutral'
                };
            }

            // Average Booking Value improvement
            if (previousKPIs.avgBookingValue > 0) {
                const avgChange = ((currentKPIs.avgBookingValue - previousKPIs.avgBookingValue) / previousKPIs.avgBookingValue) * 100;
                improvements.avgBookingValue = {
                    value: avgChange,
                    text: formatImprovementText(avgChange, previousLabel),
                    color: avgChange >= 0 ? 'positive' : 'negative'
                };
            } else {
                improvements.avgBookingValue = {
                    value: 0,
                    text: 'No previous data available.',
                    color: 'neutral'
                };
            }

            // Confirmed Bookings improvement
            if (previousKPIs.confirmedBookings > 0) {
                const confirmedChange = ((currentKPIs.confirmedBookings - previousKPIs.confirmedBookings) / previousKPIs.confirmedBookings) * 100;
                improvements.confirmedBookings = {
                    value: confirmedChange,
                    text: formatImprovementText(confirmedChange, previousLabel),
                    color: confirmedChange >= 0 ? 'positive' : 'negative'
                };
            } else {
                improvements.confirmedBookings = {
                    value: 0,
                    text: 'No previous data available.',
                    color: 'neutral'
                };
            }

            return improvements;
        }

        // Get previous period data based on current time period
        function getPreviousPeriodData(timePeriod, status) {
            if (!dashboardData || !dashboardData.bookings) return null;

            let previousRange = null;
            const now = new Date();

            // Determine previous period range
            switch (timePeriod) {
                case 'thisWeek':
                    // Previous week (7 days before current week)
                    const currentWeekStart = new Date(now);
                    currentWeekStart.setDate(now.getDate() - now.getDay());
                    currentWeekStart.setHours(0, 0, 0, 0);
                    
                    const previousWeekEnd = new Date(currentWeekStart);
                    previousWeekEnd.setDate(currentWeekStart.getDate() - 1);
                    previousWeekEnd.setHours(23, 59, 59, 999);
                    
                    const previousWeekStart = new Date(previousWeekEnd);
                    previousWeekStart.setDate(previousWeekEnd.getDate() - 6);
                    previousWeekStart.setHours(0, 0, 0, 0);
                    
                    previousRange = { start: previousWeekStart, end: previousWeekEnd };
                    break;

                case 'thisMonth':
                    // Previous month
                    const previousMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                    const previousMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);
                    previousRange = { start: previousMonthStart, end: previousMonthEnd };
                    break;

                case 'lastMonth':
                    // Month before last month
                    const monthBeforeLastStart = new Date(now.getFullYear(), now.getMonth() - 2, 1);
                    const monthBeforeLastEnd = new Date(now.getFullYear(), now.getMonth() - 1, 0, 23, 59, 59, 999);
                    previousRange = { start: monthBeforeLastStart, end: monthBeforeLastEnd };
                    break;

                case 'last3Months':
                    // 3 months before the last 3 months
                    const threeMonthsBeforeStart = new Date(now.getFullYear(), now.getMonth() - 6, 1);
                    const threeMonthsBeforeEnd = new Date(now.getFullYear(), now.getMonth() - 3, 0, 23, 59, 59, 999);
                    previousRange = { start: threeMonthsBeforeStart, end: threeMonthsBeforeEnd };
                    break;

                case 'allTime':
                    // Compare latest month vs previous month
                    const latestMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
                    const latestMonthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
                    const previousLatestMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                    const previousLatestMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);
                    
                    // For "all time", we compare current month vs previous month
                    previousRange = { start: previousLatestMonthStart, end: previousLatestMonthEnd };
                    break;

                default: {
                    // Handle explicit month keys like 'mar2025'
                    const match = /^([a-z]{3})(\d{4})$/i.exec(timePeriod || '');
                    if (!match) return null;
                    const map = { jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11 };
                    const monthIdx = map[match[1].toLowerCase()];
                    const year = parseInt(match[2], 10);
                    const prevStart = new Date(year, monthIdx - 1, 1);
                    const prevEnd = new Date(year, monthIdx, 0, 23, 59, 59, 999);
                    previousRange = { start: prevStart, end: prevEnd };
                    break;
                }
            }

            if (!previousRange) return null;

            // Filter bookings for previous period
            let previousBookings = dashboardData.bookings.filter(booking => {
                const bookingDate = new Date(booking.date);
                return bookingDate >= previousRange.start && bookingDate <= previousRange.end;
            });

            // Apply status filter if specified
            if (status && status !== '') {
                previousBookings = previousBookings.filter(booking => booking.status === status);
            }

            return {
                bookings: previousBookings,
                settings: dashboardData.settings
            };
        }

        // Format improvement text with explicit comparison label
        function formatImprovementText(change, comparedToLabel) {
            if (change === 0) return `No change compared to ${comparedToLabel}`;
            const isPositive = change > 0;
            const arrow = isPositive ? '↑' : '↓';
            const formattedChange = Math.abs(change).toFixed(1);
            return `${arrow}${formattedChange}% compared to ${comparedToLabel}`;
        }

        // Helpers to build explicit period labels
        function getMonthName(index) {
            return ['January','February','March','April','May','June','July','August','September','October','November','December'][index];
        }

        function getISOWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(),0,1));
            const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return { week: weekNo, year: d.getUTCFullYear() };
        }

        function getCurrentPeriodLabel(filters) {
            const timePeriod = filters?.timePeriod;
            const now = new Date();
            if (timePeriod === 'thisWeek') {
                const { week, year } = getISOWeekNumber(now);
                return `Week ${week}, ${year}`;
            }
            if (timePeriod === 'thisMonth') {
                return `${getMonthName(now.getMonth())} ${now.getFullYear()}`;
            }
            if (timePeriod === 'lastMonth') {
                const last = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                return `${getMonthName(last.getMonth())} ${last.getFullYear()}`;
            }
            if (timePeriod === 'last3Months') {
                const end = new Date(now.getFullYear(), now.getMonth(), 1);
                const start = new Date(now.getFullYear(), now.getMonth() - 2, 1);
                return `${getMonthName(start.getMonth())}–${getMonthName(end.getMonth())} ${end.getFullYear()}`;
            }
            if (timePeriod === 'allTime') return 'All Time';
            // Handle explicit month keys like 'mar2025'
            const match = /^([a-z]{3})(\d{4})$/i.exec(timePeriod || '');
            if (match) {
                const map = { jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11 };
                const monthIdx = map[match[1].toLowerCase()];
                const year = parseInt(match[2], 10);
                if (monthIdx != null) return `${getMonthName(monthIdx)} ${year}`;
            }
            return 'Selected period';
        }

        function getPreviousPeriodLabel(timePeriod) {
            const now = new Date();
            switch (timePeriod) {
                case 'thisWeek': {
                    const start = new Date(now);
                    start.setDate(now.getDate() - now.getDay());
                    const prevEnd = new Date(start);
                    prevEnd.setDate(start.getDate() - 1);
                    const { week, year } = getISOWeekNumber(prevEnd);
                    return `Week ${week}, ${year}`;
                }
                case 'thisMonth': {
                    const last = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                    return `${getMonthName(last.getMonth())} ${last.getFullYear()}`;
                }
                case 'lastMonth': {
                    const prev = new Date(now.getFullYear(), now.getMonth() - 2, 1);
                    return `${getMonthName(prev.getMonth())} ${prev.getFullYear()}`;
                }
                case 'last3Months': {
                    const end = new Date(now.getFullYear(), now.getMonth() - 3, 1);
                    const start = new Date(now.getFullYear(), now.getMonth() - 5, 1);
                    return `${getMonthName(start.getMonth())}–${getMonthName(end.getMonth())} ${end.getFullYear()}`;
                }
                case 'allTime': {
                    const prev = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                    return `${getMonthName(prev.getMonth())} ${prev.getFullYear()}`;
                }
                default: {
                    const match = /^([a-z]{3})(\d{4})$/i.exec(timePeriod || '');
                    if (match) {
                        const map = { jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11 };
                        const monthIdx = map[match[1].toLowerCase()];
                        const year = parseInt(match[2], 10);
                        const prev = new Date(year, monthIdx - 1, 1);
                        return `${getMonthName(prev.getMonth())} ${prev.getFullYear()}`;
                    }
                    return 'previous period';
                }
            }
        }

        // Empty-state utilities
        function getStatusLabelForEmptyMessage(status) {
            if (!status) return '';
            const map = { pending: 'pending', confirmed: 'confirmed', cancelled: 'cancelled' };
            return map[status] || status;
        }

        function buildEmptyMessage(baseType = 'data') {
            const filters = getCurrentFilters();
            const period = getCurrentPeriodLabel(filters);
            const statusLabel = getStatusLabelForEmptyMessage(filters.status);
            if (baseType === 'bookings' && statusLabel) {
                return `No ${statusLabel} bookings for ${period}.`;
            }
            if (baseType === 'bookings') {
                return `No bookings for ${period}.`;
            }
            if (statusLabel) {
                return `No ${statusLabel} data for ${period}.`;
            }
            return `No data available for ${period}.`;
        }

        function ensureEmptyState(container, message) {
            if (!container) return;
            container.style.position = container.style.position || 'relative';
            let overlay = container.querySelector('.empty-state');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'empty-state';
                container.appendChild(overlay);
            }
            // Respect Restricted Mode: hide empty-state text when locked
            if (restrictedMode) {
                overlay.textContent = 'Hidden';
            } else {
                overlay.textContent = message;
            }
        }

        function clearEmptyState(container) {
            if (!container) return;
            const overlay = container.querySelector('.empty-state');
            if (overlay) overlay.remove();
        }

        // Inject minimal styles for empty states and smooth text updates
        (function injectEmptyStateStyles(){
            const id = 'empty-state-style';
            if (document.getElementById(id)) return;
            const style = document.createElement('style');
            style.id = id;
            style.textContent = `
                .empty-state{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:var(--text-secondary);text-align:center;padding:12px;background:transparent}
            `;
            document.head.appendChild(style);
        })();

        // Render Dashboard
        function renderDashboard() {
            console.log('renderDashboard called');
            if (!filteredData) {
                console.log('No filteredData available');
                return;
            }

            console.log('Rendering dashboard with', filteredData.bookings.length, 'bookings');
            const kpis = calculateKPIs(filteredData);
            const currentFilters = getCurrentFilters();
            const improvements = calculateImprovements(filteredData, currentFilters);
            renderKPIs(kpis, improvements, currentFilters);
            renderStats();
            
            // Check if we have a saved layout to restore
            if (window.savedLayout && window.savedLayout.widgets && window.savedLayout.widgets.length > 0) {
                console.log('Restoring saved layout with', window.savedLayout.widgets.length, 'widgets');
                renderCustomLayout(window.savedLayout.widgets);
                // Clear the saved layout after using it
                window.savedLayout = null;
                return;
            }
            
            // Check if we should load a custom layout from localStorage
            const savedLayout = localStorage.getItem('dashboardLayout');
            if (currentView === 'custom' && savedLayout) {
                try {
                    const layout = JSON.parse(savedLayout);
                    if (layout.view === 'custom' && layout.widgets && layout.widgets.length > 0) {
                        renderCustomLayout(layout.widgets);
                        return;
                    }
                } catch (error) {
                    console.error('Error loading custom layout:', error);
                }
            }
            
            renderWidgets();
            
            // Apply Restricted Mode after all widgets render
            if (restrictedMode) {
                enableRestrictedMode();
            }
        }

        // Render KPI Cards
        function renderKPIs(kpis, improvements = null, currentFilters = null) {
            const kpiGrid = document.getElementById('kpiGrid');
            const isRestricted = restrictedMode;
            
            // Debug logging for KPI widget re-render
            console.log('KPI widgets re-rendered - Restricted Mode:', isRestricted);
            
            // Get status-based titles and colors
            const status = currentFilters?.status || '';
            const { titles, colors } = getStatusBasedKPITitles(status);
            
            // Get improvement data or use defaults
            const hasCurrentData = (kpis.totalBookings ?? 0) > 0 || (kpis.totalRevenue ?? 0) > 0;
            const revenueImprovement = hasCurrentData ? (improvements?.totalRevenue || { text: 'No previous data available.', color: 'neutral' }) : { text: `No data for ${getCurrentPeriodLabel(currentFilters)}.`, color: 'neutral' };
            const bookingsImprovement = hasCurrentData ? (improvements?.totalBookings || { text: 'No previous data available.', color: 'neutral' }) : { text: `No data for ${getCurrentPeriodLabel(currentFilters)}.`, color: 'neutral' };
            const avgValueImprovement = hasCurrentData ? (improvements?.avgBookingValue || { text: 'No previous data available.', color: 'neutral' }) : { text: `No data for ${getCurrentPeriodLabel(currentFilters)}.`, color: 'neutral' };
            
            kpiGrid.innerHTML = `
                <div class="kpi-card" style="--kpi-color: ${colors.revenue};">
                    <div class="kpi-header">
                        <span class="kpi-title">${titles.revenue}</span>
                        <span class="kpi-icon">💰</span>
                    </div>
                    <div class="kpi-value" ${isRestricted ? 'data-hidden="true"' : ''}>${isRestricted ? '••••' : '$' + ((kpis.totalRevenue ?? 0).toLocaleString())}</div>
                    <div class="kpi-trend ${hasCurrentData && revenueImprovement.color === 'positive' ? 'positive' : hasCurrentData && revenueImprovement.color === 'negative' ? 'negative' : ''}">
                        <span>${hasCurrentData ? (revenueImprovement.color === 'positive' ? '↗' : revenueImprovement.color === 'negative' ? '↘' : '→') : ''}</span>
                        <span>${isRestricted ? 'Hidden' : revenueImprovement.text}</span>
                    </div>
                </div>

                <div class="kpi-card" style="--kpi-color: ${colors.bookings};">
                    <div class="kpi-header">
                        <span class="kpi-title">${titles.bookings}</span>
                        <span class="kpi-icon">📅</span>
                    </div>
                    <div class="kpi-value" ${isRestricted ? 'data-hidden="true"' : ''}>${isRestricted ? '••••' : (kpis.totalBookings ?? 0)}</div>
                    <div class="kpi-trend ${hasCurrentData && bookingsImprovement.color === 'positive' ? 'positive' : hasCurrentData && bookingsImprovement.color === 'negative' ? 'negative' : ''}">
                        <span>${hasCurrentData ? (bookingsImprovement.color === 'positive' ? '↗' : bookingsImprovement.color === 'negative' ? '↘' : '→') : ''}</span>
                        <span>${isRestricted ? 'Hidden' : bookingsImprovement.text}</span>
                    </div>
                </div>

                <div class="kpi-card" style="--kpi-color: ${colors.avgValue};">
                    <div class="kpi-header">
                        <span class="kpi-title">${titles.avgValue}</span>
                        <span class="kpi-icon">📊</span>
                    </div>
                    <div class="kpi-value" ${isRestricted ? 'data-hidden="true"' : ''}>${isRestricted ? '••••' : '$' + ((kpis.avgBookingValue ?? 0).toFixed(2))}</div>
                    <div class="kpi-trend ${hasCurrentData && avgValueImprovement.color === 'positive' ? 'positive' : hasCurrentData && avgValueImprovement.color === 'negative' ? 'negative' : ''}">
                        <span>${hasCurrentData ? (avgValueImprovement.color === 'positive' ? '↗' : avgValueImprovement.color === 'negative' ? '↘' : '→') : ''}</span>
                        <span>${isRestricted ? 'Hidden' : avgValueImprovement.text}</span>
                    </div>
                </div>

                <div class="kpi-card" style="--kpi-color: var(--accent-secondary);">
                    <div class="kpi-header">
                        <span class="kpi-title">Popular Service</span>
                        <span class="kpi-icon">⭐</span>
                    </div>
                    <div class="kpi-value" style="font-size: 1.2rem;" ${isRestricted ? 'data-hidden="true"' : ''}>${isRestricted ? '••••' : kpis.popularService || 'N/A'}</div>
                    <div class="kpi-trend">
                        <span>${isRestricted ? 'Hidden' : 'Most requested'}</span>
                    </div>
                </div>
            `;
        }

        // Get status-based KPI titles and colors
        function getStatusBasedKPITitles(status) {
            const baseTitles = {
                revenue: 'Total Revenue',
                bookings: 'Total Bookings',
                avgValue: 'Avg Booking Value'
            };

            const baseColors = {
                revenue: 'var(--accent-primary)',
                bookings: 'var(--accent-secondary)',
                avgValue: 'var(--accent-warning)'
            };

            switch (status) {
                case 'confirmed':
                    return {
                        titles: {
                            revenue: 'Confirmed Revenue',
                            bookings: 'Confirmed Bookings',
                            avgValue: 'Confirmed Avg Value'
                        },
                        colors: {
                            revenue: 'var(--accent-secondary)',
                            bookings: 'var(--accent-secondary)',
                            avgValue: 'var(--accent-secondary)'
                        }
                    };
                case 'pending':
                    return {
                        titles: {
                            revenue: 'Pending Revenue',
                            bookings: 'Pending Bookings',
                            avgValue: 'Pending Avg Value'
                        },
                        colors: {
                            revenue: 'var(--accent-warning)',
                            bookings: 'var(--accent-warning)',
                            avgValue: 'var(--accent-warning)'
                        }
                    };
                case 'cancelled':
                    return {
                        titles: {
                            revenue: 'Cancelled Revenue (Loss)',
                            bookings: 'Cancelled Bookings',
                            avgValue: 'Cancelled Avg Value'
                        },
                        colors: {
                            revenue: 'var(--accent-danger)',
                            bookings: 'var(--accent-danger)',
                            avgValue: 'var(--accent-danger)'
                        }
                    };
                default:
                    return {
                        titles: baseTitles,
                        colors: baseColors
                    };
            }
        }

        // Old functions removed - using new Restricted Mode system

        // Old initializeLockSystem function removed - using initializeRestrictedMode

        // Wait for DOM elements to be ready
        function waitForElement(selector, timeout = 1000) {
            return new Promise((resolve, reject) => {
                const element = document.querySelector(selector);
                if (element) {
                    resolve(element);
                    return;
                }
                
                const observer = new MutationObserver((mutations, obs) => {
                    const element = document.querySelector(selector);
                    if (element) {
                        obs.disconnect();
                        resolve(element);
                    }
                });
                
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
                
                setTimeout(() => {
                    observer.disconnect();
                    reject(new Error(`Element ${selector} not found within ${timeout}ms`));
                }, timeout);
            });
        }

        // Automatic widget insertion functions removed - widgets must be explicitly added via Add Widget

        // Render Widgets
        function renderWidgets() {
            const grid = document.getElementById('dashboardGrid');
            console.log('Rendering widgets for view:', currentView, 'custom layout:', currentCustomLayout);
            
            // Clear any existing widgets to prevent duplication
            grid.innerHTML = '';
            
            // Always render widgets, even with no data - show zeros instead of empty state
            if (currentView === 'light') {
                // Light view removed - redirect to custom or full view
                currentView = 'full';
                renderDashboard();
                return;
            } else if (currentView === 'custom') {
                // Custom view - load specific custom layout or show empty state
                const layout = getCurrentCustomLayout();
                if (layout && layout.widgets && layout.widgets.length > 0) {
                    // Render the custom layout widgets
                    renderCustomLayout(layout.widgets);
                    return;
                } else {
                    // Custom view - empty dashboard for user to build
                    grid.innerHTML = `
                        <div class="custom-empty-state">
                            <div class="custom-empty-content">
                                <div class="custom-empty-icon">🎨</div>
                                <h3 class="custom-empty-title">Custom Dashboard</h3>
                                <p class="custom-empty-description">Start building your custom dashboard by adding widgets below.</p>
                                <button class="btn btn-primary custom-empty-button" onclick="openModal('addWidgetModal')">
                                    <span>➕</span> Add Your First Widget
                                </button>
                            </div>
                        </div>
                    `;
                    
                    // Ensure Add Widget placeholder is present even in empty state
                    setTimeout(() => {
                        ensureAddWidgetPlaceholder();
                    }, 100);
                }
            } else {
                // Full view
                grid.innerHTML = `
                    <div class="widget widget-medium" id="widget-revenue">
                        <div class="widget-header">
                            <h3 class="widget-title">Revenue Chart</h3>
                            <div class="widget-actions no-print">
                                <button class="widget-btn" onclick="refreshWidget('revenue')">🔄</button>
                                <button class="widget-btn" onclick="expandWidget('revenue')">⛶</button>
                            </div>
                        </div>
                        <div class="booking-list-filter-status" id="filter-status-widget-revenue">
                            <!-- Filter status will be displayed here -->
                        </div>
                        <div class="chart-container">
                            <canvas id="revenueChart"></canvas>
                        </div>
                        <div class="resize-handle"></div>
                    </div>

                    <div class="widget widget-medium" id="widget-services">
                        <div class="widget-header">
                            <h3 class="widget-title">Service Distribution</h3>
                            <div class="widget-actions no-print">
                                <button class="widget-btn" onclick="refreshWidget('services')">🔄</button>
                            </div>
                        </div>
                        <div class="booking-list-filter-status" id="filter-status-widget-services">
                            <!-- Filter status will be displayed here -->
                        </div>
                        <div class="chart-container">
                            <canvas id="servicesChart"></canvas>
                        </div>
                        <div class="resize-handle"></div>
                    </div>

                    <div class="widget widget-full" id="widget-bookings">
                        <div class="widget-header">
                            <h3 class="widget-title">Bookings</h3>
                            <div class="widget-actions no-print">
                                <button class="widget-btn" onclick="toggleBookingWidgetMode('widget-bookings')" title="Toggle view mode">⛶</button>
                                <button class="widget-btn" onclick="exportBookings()">📥</button>
                                <button class="widget-btn" onclick="refreshWidget('bookings')">🔄</button>
                                <button class="widget-btn" onclick="removeWidget('widget-bookings')" title="Delete widget">🗑️</button>
                            </div>
                        </div>
                        <div class="booking-list-filter-status" id="booking-list-filter-status-widget-bookings">
                            <!-- Filter status will be displayed here -->
                        </div>
                        <div id="table-widget-bookings"></div>
                    </div>

                    <div class="widget widget-medium" id="widget-stats">
                        <div class="widget-header">
                            <h3 class="widget-title">Quick Stats</h3>
                            <div class="widget-actions no-print">
                                <button class="widget-btn" onclick="refreshWidget('stats')">🔄</button>
                            </div>
                        </div>
                        <div class="stats-grid" id="statsGrid"></div>
                    </div>

                    <div class="widget widget-medium" id="widget-timeline">
                        <div class="widget-header">
                            <h3 class="widget-title">Daily Bookings Timeline</h3>
                            <div class="widget-actions no-print">
                                <button class="widget-btn" onclick="refreshWidget('timeline')">🔄</button>
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="timelineChart"></canvas>
                        </div>
                    </div>
                `;
            }

            // Initialize charts and tables only for non-custom views
            if (currentView !== 'custom') {
                // Use a more robust initialization approach
                Promise.all([
                    waitForElement('#revenueChart', 500).catch(() => null),
                    waitForElement('#timelineChart', 500).catch(() => null),
                    waitForElement('#statsGrid', 500).catch(() => null),
                    waitForElement('#table-widget-bookings', 500).catch(() => null)
                ]).then(() => {
                    // All elements are ready, initialize charts
                    createRevenueChart();
                    if (currentView === 'full') {
                        createServicesChart();
                        createTimelineChart();
                        renderStats();
                    }
                    // Initialize Bookings widget on full view load
                    createUnifiedBookingTable(document.getElementById('table-widget-bookings'), 'widget-bookings', 'large');
                    updateBookingListFilterStatus('widget-bookings');
                    initializeDraggableWidgets();
                    
                    // Re-apply Restricted Mode after content has been rendered
                    if (restrictedMode) {
                        enableRestrictedMode();
                    }
                    
                    // Restore widget states (expanded/collapsed)
                    restoreWidgetStates();
                }).catch(() => {
                    // Fallback to setTimeout if Promise approach fails
                    setTimeout(() => {
                        createRevenueChart();
                        if (currentView === 'full') {
                            createServicesChart();
                            createTimelineChart();
                            renderStats();
                        }
                        // Initialize Bookings widget on full view load
                        createUnifiedBookingTable(document.getElementById('table-widget-bookings'), 'widget-bookings', 'large');
                        updateBookingListFilterStatus('widget-bookings');
                        initializeDraggableWidgets();
                        
                        // Re-apply Restricted Mode after content has been rendered
                        if (restrictedMode) {
                            enableRestrictedMode();
                        }
                        
                        // Restore widget states (expanded/collapsed)
                        restoreWidgetStates();
                    }, 300);
                });
            }
        }

        // Create Revenue Chart
        function createRevenueChart() {
            const canvas = document.getElementById('revenueChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            // Ensure a reflow for fresh animation after page refresh
            void canvas.offsetHeight;
            
            // Destroy existing chart instance before creating new one
            // Check both our stored instance and Chart.js's internal registry
            const existingChart = Chart.getChart(canvas);
            if (existingChart) {
                try {
                    existingChart.destroy();
                } catch (e) {
                    console.warn('Error destroying existing revenue chart:', e);
                }
            }
            if (revenueChartInstance && revenueChartInstance !== existingChart) {
                try {
                    revenueChartInstance.destroy();
                } catch (e) {
                    console.warn('Error destroying stored revenue chart:', e);
                }
            }
            revenueChartInstance = null;
            
            // Prepare data by date
            const revenueByDate = {};
            filteredData.bookings.forEach(booking => {
                const date = booking.date;
                if (!revenueByDate[date]) revenueByDate[date] = 0;
                
                booking.services.forEach(serviceId => {
                    const service = filteredData.settings.serviceTypes[serviceId];
                    if (service) {
                        revenueByDate[date] += service.price;
                    }
                });
            });

            const dates = Object.keys(revenueByDate).sort();
            const revenues = dates.map(date => revenueByDate[date]);

            // Handle empty data case with overlay
            const container = canvas.closest('.chart-container');
            if (dates.length === 0) {
                const currentLabel = getCurrentPeriodLabel(getCurrentFilters());
                ensureEmptyState(container, `No data available for ${currentLabel}.`);
                updateRevenueFilterStatus('widget-revenue');
                return;
            } else {
                clearEmptyState(container);
            }

            revenueChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: [{
                        label: 'Daily Revenue ($)',
                        data: revenues,
                        borderColor: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim(),
                        backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim() + '20',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 1000,
                        easing: 'easeOutQuart'
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return '$' + context.parsed.y.toLocaleString();
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value;
                                }
                            }
                        }
                    }
                }
            });
            
            // Update filter status display
            updateRevenueFilterStatus('widget-revenue');
        }

        // Create Services Distribution Chart
        function createServicesChart() {
            const canvas = document.getElementById('servicesChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            // Ensure a reflow for fresh animation after page refresh
            void canvas.offsetHeight;
            
            // Destroy existing chart instance before creating new one
            // Check both our stored instance and Chart.js's internal registry
            const existingChart = Chart.getChart(canvas);
            if (existingChart) {
                try {
                    existingChart.destroy();
                } catch (e) {
                    console.warn('Error destroying existing services chart:', e);
                }
            }
            if (servicesChartInstance && servicesChartInstance !== existingChart) {
                try {
                    servicesChartInstance.destroy();
                } catch (e) {
                    console.warn('Error destroying stored services chart:', e);
                }
            }
            servicesChartInstance = null;
            
            // Count services
            const serviceCount = {};
            filteredData.bookings.forEach(booking => {
                booking.services.forEach(serviceId => {
                    const service = filteredData.settings.serviceTypes[serviceId];
                    if (service) {
                        serviceCount[service.name] = (serviceCount[service.name] || 0) + 1;
                    }
                });
            });

            const labels = Object.keys(serviceCount);
            const data = Object.values(serviceCount);

            // Handle empty data case with overlay
            const container = canvas.closest('.chart-container');
            if (labels.length === 0) {
                const currentLabel = getCurrentPeriodLabel(getCurrentFilters());
                ensureEmptyState(container, `No data available for ${currentLabel}.`);
                updateServicesFilterStatus('widget-services');
                return;
            } else {
                clearEmptyState(container);
            }

            servicesChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: [
                            '#3498db',
                            '#2ecc71',
                            '#f39c12',
                            '#e74c3c',
                            '#9b59b6',
                            '#1abc9c',
                            '#34495e',
                            '#e67e22',
                            '#95a5a6',
                            '#16a085'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        animateRotate: true,
                        animateScale: true,
                        duration: 1000,
                        easing: 'easeOutQuart'
                    },
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
            
            // Update filter status display
            updateServicesFilterStatus('widget-services');
        }

        // Create Timeline Chart
        function createTimelineChart() {
            const canvas = document.getElementById('timelineChart');
            if (!canvas) {
                console.warn('Timeline chart canvas not found');
                return;
            }

            const ctx = canvas.getContext('2d');
            // Ensure a reflow for fresh animation after page refresh
            void canvas.offsetHeight;
            
            // Destroy existing chart instance before creating new one
            // Check both our stored instance and Chart.js's internal registry
            const existingChart = Chart.getChart(canvas);
            if (existingChart) {
                try {
                    existingChart.destroy();
                } catch (e) {
                    console.warn('Error destroying existing timeline chart:', e);
                }
            }
            if (timelineChartInstance && timelineChartInstance !== existingChart) {
                try {
                    timelineChartInstance.destroy();
                } catch (e) {
                    console.warn('Error destroying stored timeline chart:', e);
                }
            }
            timelineChartInstance = null;
            
            // Count bookings by date
            const bookingsByDate = {};
            filteredData.bookings.forEach(booking => {
                const date = booking.date;
                bookingsByDate[date] = (bookingsByDate[date] || 0) + 1;
            });

            const dates = Object.keys(bookingsByDate).sort();
            const counts = dates.map(date => bookingsByDate[date]);

            // Handle empty data case with overlay
            const container = canvas.closest('.chart-container');
            if (dates.length === 0) {
                const currentLabel = getCurrentPeriodLabel(getCurrentFilters());
                ensureEmptyState(container, `No data available for ${currentLabel}.`);
                return;
            } else {
                clearEmptyState(container);
            }

            timelineChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: dates,
                    datasets: [{
                        label: 'Bookings per Day',
                        data: counts,
                        backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--accent-secondary').trim(),
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 1000,
                        easing: 'easeOutQuart'
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        // Render Stats
        function renderStats() {
            const statsGrid = document.getElementById('statsGrid');
            if (!statsGrid) {
                console.warn('Stats grid container not found');
                return;
            }

            const services = filteredData.settings.serviceTypes;
            const totalServices = Object.keys(services).length;
            const avgPrice = totalServices > 0 ? Object.values(services).reduce((sum, s) => sum + s.price, 0) / totalServices : 0;
            const maxAppointments = filteredData.settings.maxAppointmentsPerDay;
            const isRestricted = restrictedMode;

            statsGrid.innerHTML = `
                <div class="stat-item">
                    <div class="stat-label">Available Services</div>
                    <div class="stat-value">${isRestricted ? '••••' : totalServices}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Avg Service Price</div>
                    <div class="stat-value">${isRestricted ? '••••' : '$' + avgPrice.toFixed(2)}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Max Daily Appointments</div>
                    <div class="stat-value">${isRestricted ? '••••' : maxAppointments}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Time Slots</div>
                    <div class="stat-value">${isRestricted ? '••••' : filteredData.settings.availableTimeSlots.length}</div>
                </div>
            `;
        }
        // Legacy function - now handled by createUnifiedBookingTable
        function renderBookingsTable() {
            console.log('renderBookingsTable called - redirecting to createUnifiedBookingTable');
            const bookingsWidget = document.querySelector('#widget-bookings, [id*="bookings"]');
            if (bookingsWidget) {
                const tableContainer = document.querySelector('#table-widget-bookings, [id*="table-"][id*="bookings"]');
                if (tableContainer) {
                    createUnifiedBookingTable(tableContainer, bookingsWidget.id || 'widget-bookings', 'large');
                    updateBookingListFilterStatus(bookingsWidget.id || 'widget-bookings');
                }
            }
        }

        // Filter Functions
        function applyFilters() {
            console.log('applyFilters called');
            
            // Save current widget positions before applying filters
            let savedLayout = null;
            if (currentView === 'custom' && currentCustomLayout) {
                console.log('Saving current custom layout before applying filters...');
                saveCurrentCustomLayout();
                savedLayout = getCurrentCustomLayout();
            } else if (currentView !== 'custom') {
                console.log('Saving current standard layout before applying filters...');
                savedLayout = createCurrentLayout();
            }
            
            // No automatic widget creation - filters only affect existing widgets
            
            const timePeriod = document.getElementById('timePeriodFilter').value;
            const status = document.getElementById('statusFilter').value;
            
            console.log('Filter values:', { timePeriod, status });
            console.log('Original bookings count:', dashboardData.bookings.length);

            let filtered = [...dashboardData.bookings];

            // Apply time period filter
            if (timePeriod) {
                if (timePeriod === 'thisWeek') {
                    // Smart "This Week" - Sunday to Saturday
                    const now = new Date();
                    const dayOfWeek = now.getDay(); // 0 = Sunday, 1 = Monday, etc.
                    
                    // Calculate start of week (Sunday)
                    const startOfWeek = new Date(now);
                    startOfWeek.setDate(now.getDate() - dayOfWeek);
                    startOfWeek.setHours(0, 0, 0, 0);
                    
                    // Calculate end of week (Saturday)
                    const endOfWeek = new Date(startOfWeek);
                    endOfWeek.setDate(startOfWeek.getDate() + 6);
                    endOfWeek.setHours(23, 59, 59, 999);
                    
                    // Format dates to match booking data format (YYYY/MM/DD)
                    const formattedStartDate = startOfWeek.getFullYear() + '/' + 
                        String(startOfWeek.getMonth() + 1).padStart(2, '0') + '/' + 
                        String(startOfWeek.getDate()).padStart(2, '0');
                    const formattedEndDate = endOfWeek.getFullYear() + '/' + 
                        String(endOfWeek.getMonth() + 1).padStart(2, '0') + '/' + 
                        String(endOfWeek.getDate()).padStart(2, '0');
                    
                    console.log('This week range:', formattedStartDate, 'to', formattedEndDate);
                    filtered = filtered.filter(b => b.date >= formattedStartDate && b.date <= formattedEndDate);
                    
                } else if (timePeriod === 'thisMonth') {
                    // Current month
                    const now = new Date();
                    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                    const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                    
                    const formattedStartDate = startOfMonth.getFullYear() + '/' + 
                        String(startOfMonth.getMonth() + 1).padStart(2, '0') + '/' + 
                        String(startOfMonth.getDate()).padStart(2, '0');
                    const formattedEndDate = endOfMonth.getFullYear() + '/' + 
                        String(endOfMonth.getMonth() + 1).padStart(2, '0') + '/' + 
                        String(endOfMonth.getDate()).padStart(2, '0');
                    
                    console.log('This month range:', formattedStartDate, 'to', formattedEndDate);
                    filtered = filtered.filter(b => b.date >= formattedStartDate && b.date <= formattedEndDate);
                    
                } else if (timePeriod === 'lastMonth') {
                    // Last month
                    const now = new Date();
                    const startOfLastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                    const endOfLastMonth = new Date(now.getFullYear(), now.getMonth(), 0);
                    
                    const formattedStartDate = startOfLastMonth.getFullYear() + '/' + 
                        String(startOfLastMonth.getMonth() + 1).padStart(2, '0') + '/' + 
                        String(startOfLastMonth.getDate()).padStart(2, '0');
                    const formattedEndDate = endOfLastMonth.getFullYear() + '/' + 
                        String(endOfLastMonth.getMonth() + 1).padStart(2, '0') + '/' + 
                        String(endOfLastMonth.getDate()).padStart(2, '0');
                    
                    console.log('Last month range:', formattedStartDate, 'to', formattedEndDate);
                    filtered = filtered.filter(b => b.date >= formattedStartDate && b.date <= formattedEndDate);
                    
                } else if (timePeriod === 'jan2025') {
                    filtered = filtered.filter(b => b.date >= '2025/01/01' && b.date <= '2025/01/31');
                } else if (timePeriod === 'feb2025') {
                    filtered = filtered.filter(b => b.date >= '2025/02/01' && b.date <= '2025/02/28');
                } else if (timePeriod === 'mar2025') {
                    filtered = filtered.filter(b => b.date >= '2025/03/01' && b.date <= '2025/03/31');
                } else if (timePeriod === 'apr2025') {
                    filtered = filtered.filter(b => b.date >= '2025/04/01' && b.date <= '2025/04/30');
                } else if (timePeriod === 'may2025') {
                    filtered = filtered.filter(b => b.date >= '2025/05/01' && b.date <= '2025/05/31');
                } else if (timePeriod === 'jun2025') {
                    filtered = filtered.filter(b => b.date >= '2025/06/01' && b.date <= '2025/06/30');
                } else if (timePeriod === 'jul2025') {
                    filtered = filtered.filter(b => b.date >= '2025/07/01' && b.date <= '2025/07/31');
                } else if (timePeriod === 'aug2025') {
                    filtered = filtered.filter(b => b.date >= '2025/08/01' && b.date <= '2025/08/31');
                } else if (timePeriod === 'sep2025') {
                    filtered = filtered.filter(b => b.date >= '2025/09/01' && b.date <= '2025/09/30');
                } else if (timePeriod === 'oct2025') {
                    filtered = filtered.filter(b => b.date >= '2025/10/01' && b.date <= '2025/10/31');
                } else if (timePeriod === 'nov2025') {
                    filtered = filtered.filter(b => b.date >= '2025/11/01' && b.date <= '2025/11/30');
                } else if (timePeriod === 'dec2025') {
                    filtered = filtered.filter(b => b.date >= '2025/12/01' && b.date <= '2025/12/31');
                }
                
                console.log('After date filter:', filtered.length);
            }

            // Apply status filter
            if (status) {
                filtered = filtered.filter(b => b.status === status);
                console.log('After status filter:', filtered.length);
            }

            filteredData = {
                ...dashboardData,
                bookings: filtered
            };

            console.log('Final filtered data:', filteredData.bookings.length);
            
            // Refresh calendar widget if it exists
            if (currentCalendarWidget) {
                renderCalendar();
            }
            
            // Refresh all booking list widgets
            refreshAllBookingListWidgets();
            
            // Render dashboard with filtered data
            renderDashboard();
            // Force refresh for charts to ensure no stale data remains
            createRevenueChart();
            if (currentView === 'full') {
                createServicesChart();
                createTimelineChart();
            }
            
            // Restore saved widget positions after rendering
            if (savedLayout && savedLayout.widgets && savedLayout.widgets.length > 0) {
                console.log('Restoring saved widget positions after applying filters...');
                setTimeout(() => {
                    if (currentView === 'custom' && currentCustomLayout) {
                        // For custom layouts, restore the saved custom layout
                        renderCustomLayout(savedLayout.widgets);
                    } else {
                        // For standard layouts, restore the saved layout
                        window.savedLayout = savedLayout;
                        renderDashboard();
                    }
                }, 100);
            }
            
            triggerAutoSave(); // Auto-save when filters change
            
            let message = `Filtered to ${filtered.length} bookings`;
            if (timePeriod) {
                const periodNames = {
                    'thisWeek': 'This Week',
                    'thisMonth': 'This Month',
                    'lastMonth': 'Last Month',
                    'jan2025': 'Jan 2025',
                    'feb2025': 'Feb 2025',
                    'mar2025': 'Mar 2025',
                    'apr2025': 'Apr 2025',
                    'may2025': 'May 2025',
                    'jun2025': 'Jun 2025',
                    'jul2025': 'Jul 2025',
                    'aug2025': 'Aug 2025',
                    'sep2025': 'Sep 2025',
                    'oct2025': 'Oct 2025',
                    'nov2025': 'Nov 2025',
                    'dec2025': 'Dec 2025'
                };
                message += ` (${periodNames[timePeriod]})`;
            }
            
            // Show appropriate message based on results
            if (filtered.length === 0) {
                message = 'No bookings found for the selected criteria';
                showToast(message, 'warning');
            } else {
                showToast(message, 'success');
            }
        }

        function resetFilters() {
            document.getElementById('timePeriodFilter').value = '';
            document.getElementById('statusFilter').value = '';
            filteredData = { ...dashboardData };
            
            // No automatic widget creation - filters only affect existing widgets
            
            // Refresh calendar widget if it exists
            if (currentCalendarWidget) {
                renderCalendar();
            }
            
            // Refresh all booking list widgets
            refreshAllBookingListWidgets();
            
            renderDashboard();
            triggerAutoSave(); // Auto-save when filters reset
            showToast('Filters reset', 'success');
        }

        // ============================================================================
        // ENHANCED PDF EXPORT SYSTEM - Improved Version
        // ============================================================================

        // Configuration Constants
        const PDF_CONFIG = {
            pageWidth: 210,
            pageHeight: 297,
            marginX: 20,
            marginY: 20,
            maxContentHeight: 270,
            defaultFontSize: 10,
            colors: {
                black: [0, 0, 0],
                darkGray: [64, 64, 64],
                mediumGray: [128, 128, 128],
                lightGray: [192, 192, 192],
                white: [255, 255, 255]
            },
            maxBookingsPerExport: 100,
            maxRowsPerPage: 25,
            logoPath: 'logo.png',
            logoSize: { width: 20, height: 15 }
        };

        // ============================================================================
        // TIME RANGE UTILITIES
        // ============================================================================

        class TimeRangeFilter {
            static getDateRange(timeRange, customStart, customEnd) {
                const now = new Date();
                const ranges = {
                    'this-week': () => {
                        const start = new Date(now);
                        start.setDate(now.getDate() - now.getDay());
                        start.setHours(0, 0, 0, 0);
                        const end = new Date(start);
                        end.setDate(start.getDate() + 6);
                        end.setHours(23, 59, 59, 999);
                        return { start, end };
                    },
                    'this-month': () => {
                        const start = new Date(now.getFullYear(), now.getMonth(), 1);
                        const end = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
                        return { start, end };
                    },
                    'last-month': () => {
                        const start = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                        const end = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);
                        return { start, end };
                    },
                    'last-3-months': () => {
                        const start = new Date(now.getFullYear(), now.getMonth() - 3, 1);
                        const end = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
                        return { start, end };
                    },
                    'custom': () => {
                        if (customStart && customEnd) {
                            return {
                                start: new Date(customStart),
                                end: new Date(customEnd)
                            };
                        }
                        return null;
                    }
                };

                return ranges[timeRange]?.() || null;
            }

            static filterDataByRange(data, timeRange, customStart, customEnd) {
                const dateRange = this.getDateRange(timeRange, customStart, customEnd);
                
                if (!dateRange || !data?.bookings) {
                    return data;
                }

                return {
                    ...data,
                    bookings: data.bookings.filter(booking => {
                        const bookingDate = new Date(booking.date);
                        return bookingDate >= dateRange.start && bookingDate <= dateRange.end;
                    })
                };
            }
        }

        // ============================================================================
        // DATA CALCULATION UTILITIES
        // ============================================================================

        class DataCalculator {
            static calculateKPIs(data) {
                if (!data?.bookings?.length) {
                    return {
                        totalRevenue: 0,
                        totalBookings: 0,
                        avgBookingValue: 0,
                        popularService: 'N/A'
                    };
                }

                let totalRevenue = 0;
                const serviceCounts = {};

                data.bookings.forEach(booking => {
                    booking.services?.forEach(serviceId => {
                        const service = data.settings?.serviceTypes?.[serviceId];
                        if (service) {
                            totalRevenue += service.price || 0;
                            serviceCounts[serviceId] = (serviceCounts[serviceId] || 0) + 1;
                        }
                    });
                });

                const popularServiceId = Object.entries(serviceCounts)
                    .sort(([, a], [, b]) => b - a)[0]?.[0];
                
                const popularService = popularServiceId 
                    ? data.settings.serviceTypes[popularServiceId]?.name 
                    : 'N/A';

                return {
                    totalRevenue,
                    totalBookings: data.bookings.length,
                    avgBookingValue: data.bookings.length > 0 ? totalRevenue / data.bookings.length : 0,
                    popularService
                };
            }

            static calculateRevenueByDate(bookings, serviceTypes, limit = 15) {
                const revenueMap = new Map();

                bookings.forEach(booking => {
                    const date = booking.date;
                    const current = revenueMap.get(date) || { revenue: 0, bookings: 0 };
                    
                    let bookingTotal = 0;
                    booking.services?.forEach(serviceId => {
                        const service = serviceTypes?.[serviceId];
                        if (service) bookingTotal += service.price || 0;
                    });

                    current.revenue += bookingTotal;
                    current.bookings += 1;
                    revenueMap.set(date, current);
                });

                return Array.from(revenueMap.entries())
                    .map(([date, data]) => ({ date, ...data }))
                    .sort((a, b) => new Date(a.date) - new Date(b.date))
                    .slice(-limit);
            }

            static calculateServiceDistribution(bookings, serviceTypes, limit = 8) {
                const serviceCounts = new Map();

                bookings.forEach(booking => {
                    booking.services?.forEach(serviceId => {
                        serviceCounts.set(serviceId, (serviceCounts.get(serviceId) || 0) + 1);
                    });
                });

                const total = Array.from(serviceCounts.values()).reduce((sum, count) => sum + count, 0);

                return Array.from(serviceCounts.entries())
                    .map(([serviceId, count]) => ({
                        serviceId,
                        name: serviceTypes?.[serviceId]?.name || serviceId,
                        count,
                        percentage: total > 0 ? (count / total) * 100 : 0
                    }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, limit);
            }

            static calculateBookingTotal(booking, serviceTypes) {
                return booking.services?.reduce((total, serviceId) => {
                    const service = serviceTypes?.[serviceId];
                    return total + (service?.price || 0);
                }, 0) || 0;
            }
        }

        // ============================================================================
        // PDF GENERATION UTILITIES
        // ============================================================================

        class PDFGenerator {
            constructor(jsPDF, filters = []) {
                this.pdf = new jsPDF('p', 'mm', 'a4');
                this.yPos = 20;
                this.pageNumber = 1;
                this.colors = PDF_CONFIG.colors;
                this.filters = filters;
            }

            checkPageBreak(requiredSpace = 30) {
                if (this.yPos + requiredSpace > PDF_CONFIG.maxContentHeight) {
                    this.addPage();
                    return true;
                }
                return false;
            }

            addPage() {
                this.pdf.addPage();
                this.yPos = PDF_CONFIG.marginY;
                this.pageNumber++;
            }

            setTextStyle(size, color) {
                this.pdf.setFontSize(size);
                this.pdf.setTextColor(...this.colors[color]);
            }

            addSectionHeader(title) {
                this.setTextStyle(14, 'black');
                this.pdf.text(title, PDF_CONFIG.marginX, this.yPos);
                this.yPos += 10;

                this.pdf.setDrawColor(...this.colors.lightGray);
                this.pdf.line(PDF_CONFIG.marginX, this.yPos, 190, this.yPos);
                this.yPos += 8;
            }

            addTableHeader(headers, positions) {
                this.pdf.setFillColor(...this.colors.lightGray);
                this.pdf.rect(PDF_CONFIG.marginX, this.yPos - 5, 170, 8, 'F');
                
                this.setTextStyle(9, 'black');
                headers.forEach((header, i) => {
                    this.pdf.text(header, positions[i], this.yPos);
                });
                this.yPos += 10;
            }

            addFooter() {
                const footerY = 285;
                this.pdf.setDrawColor(...this.colors.lightGray);
                this.pdf.line(20, footerY, 190, footerY);
                
                this.setTextStyle(8, 'mediumGray');
                this.pdf.text('Venus Dashboard Report - Confidential', 20, 290);
                this.pdf.text(`Page ${this.pageNumber}`, 180, 290);
            }

            async addHeader() {
                // Calculate header height based on filters
                const baseHeight = 25;
                const filterHeight = this.filters && this.filters.length > 0 ? (this.filters.length * 3) + 10 : 0;
                const totalHeight = baseHeight + filterHeight;
                
                // Header background
                this.pdf.setFillColor(...this.colors.lightGray);
                this.pdf.rect(15, 10, 180, totalHeight, 'F');
                
                // Try to load logo
                try {
                    const logoImg = await ImageLoader.loadLogo();
                    this.pdf.addImage(
                        logoImg, 
                        'PNG', 
                        20, 
                        15, 
                        PDF_CONFIG.logoSize.width, 
                        PDF_CONFIG.logoSize.height
                    );
                } catch (error) {
                    // Fallback to placeholder
                    this.pdf.setFillColor(...this.colors.darkGray);
                    this.pdf.rect(20, 15, 20, 15, 'F');
                }
                
                // Report title
                this.setTextStyle(18, 'black');
                this.pdf.text('Venus Dashboard Report', 50, 20);
                
                // Date generated
                this.setTextStyle(10, 'mediumGray');
                this.pdf.text(`Generated: ${new Date().toLocaleString()}`, 50, 26);
                
                // Add filter information if available
                console.log('PDFGenerator filters:', this.filters);
                if (this.filters && this.filters.length > 0) {
                    // Add separator line
                    this.pdf.setDrawColor(...this.colors.mediumGray);
                    this.pdf.line(50, 30, 190, 30);
                    
                    this.setTextStyle(9, 'darkGray');
                    let filterY = 32;
                    
                    this.filters.forEach(filter => {
                        console.log('Adding filter text:', filter, 'at Y:', filterY);
                        // Simple text output without complex wrapping for now
                        this.pdf.text(filter, 50, filterY);
                        filterY += 4;
                    });
                    
                    // Adjust yPos based on how many filter lines we added
                    this.yPos = Math.max(45, filterY + 5);
                } else {
                    console.log('No filters to display');
                    this.yPos = 45;
                }
            }

            save(filename = 'venus-dashboard-report.pdf') {
                this.addFooter();
                this.pdf.save(filename);
            }
        }

        // ============================================================================
        // IMAGE LOADER
        // ============================================================================

        class ImageLoader {
            static async loadLogo() {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error('Logo not found'));
                    img.src = PDF_CONFIG.logoPath;
                    
                    // Timeout after 3 seconds
                    setTimeout(() => reject(new Error('Logo load timeout')), 3000);
                });
            }

            static async canvasToDataURL(canvas) {
                try {
                    return canvas.toDataURL('image/png');
                } catch (error) {
                    console.error('Canvas export error:', error);
                    throw error;
                }
            }
        }
        // ============================================================================
        // EXPORT SECTIONS
        // ============================================================================

        class ExportSections {
            static async addKPISection(generator, data) {
                generator.checkPageBreak(50);
                generator.addSectionHeader('Key Performance Indicators');

                const kpis = DataCalculator.calculateKPIs(data);
                generator.setTextStyle(10, 'black');

                const kpiData = [
                    [`Total Revenue: $${kpis.totalRevenue.toLocaleString()}`, 
                     `Total Bookings: ${kpis.totalBookings}`],
                    [`Average Booking Value: $${kpis.avgBookingValue.toFixed(2)}`, 
                     `Most Popular Service: ${kpis.popularService}`]
                ];

                kpiData.forEach(row => {
                    row.forEach((text, index) => {
                        generator.pdf.text(text, PDF_CONFIG.marginX + (index * 85), generator.yPos);
                    });
                    generator.yPos += 8;
                });

                generator.yPos += 15;
            }

            static async addRevenueChart(generator, data, options = {}) {
                generator.checkPageBreak(100);
                generator.addSectionHeader('Revenue Analysis');

                // Try to export chart if available
                const chartCanvas = document.querySelector('canvas[id*="revenue"]');
                if (chartCanvas) {
                    try {
                        const imgData = await ImageLoader.canvasToDataURL(chartCanvas);
                        const aspectRatio = chartCanvas.width / chartCanvas.height;
                        const width = 170;
                        const height = Math.min(width / aspectRatio, 80);
                        
                        generator.pdf.addImage(imgData, 'PNG', 20, generator.yPos, width, height);
                        generator.yPos += height + 10;
                    } catch (error) {
                        console.log('Chart export failed, using table');
                    }
                }

                // Revenue table
                const revenueData = DataCalculator.calculateRevenueByDate(
                    data.bookings, 
                    data.settings?.serviceTypes
                );

                generator.addTableHeader(
                    ['Date', 'Revenue', 'Bookings'],
                    [25, 80, 130]
                );

                generator.setTextStyle(9, 'darkGray');
                revenueData.forEach(row => {
                    if (generator.checkPageBreak()) {
                        generator.addTableHeader(['Date', 'Revenue', 'Bookings'], [25, 80, 130]);
                    }
                    
                    generator.pdf.text(row.date, 25, generator.yPos);
                    generator.pdf.text('$' + row.revenue.toLocaleString(), 80, generator.yPos);
                    generator.pdf.text(row.bookings.toString(), 130, generator.yPos);
                    generator.yPos += 7;
                });

                generator.yPos += 15;
            }

            static async addServiceDistribution(generator, data) {
                generator.checkPageBreak(80);
                generator.addSectionHeader('Service Distribution');

                const distribution = DataCalculator.calculateServiceDistribution(
                    data.bookings,
                    data.settings?.serviceTypes
                );

                generator.addTableHeader(
                    ['Service', 'Count', 'Percentage'],
                    [25, 100, 150]
                );

                generator.setTextStyle(9, 'darkGray');
                distribution.forEach(item => {
                    generator.pdf.text(item.name, 25, generator.yPos);
                    generator.pdf.text(item.count.toString(), 100, generator.yPos);
                    generator.pdf.text(item.percentage.toFixed(1) + '%', 150, generator.yPos);
                    generator.yPos += 7;
                });

                generator.yPos += 15;
            }

            static async addBookingsTable(generator, data) {
                generator.checkPageBreak(50);
                generator.addSectionHeader('Booking Details');

                const totalBookings = data.bookings?.length || 0;
                const maxBookings = PDF_CONFIG.maxBookingsPerExport;
                const bookingsToShow = data.bookings?.slice(0, maxBookings) || [];

                if (totalBookings > maxBookings) {
                    generator.setTextStyle(9, 'mediumGray');
                    generator.pdf.text(
                        `Showing ${maxBookings} of ${totalBookings} bookings (performance optimized)`,
                        25,
                        generator.yPos
                    );
                    generator.yPos += 8;
                }

                const headers = ['Date', 'Customer', 'Services', 'Total', 'Status'];
                const positions = [25, 45, 85, 130, 160];
                
                generator.addTableHeader(headers, positions);
                generator.setTextStyle(7, 'darkGray');

                bookingsToShow.forEach(booking => {
                    if (generator.checkPageBreak()) {
                        generator.addTableHeader(headers, positions);
                        generator.setTextStyle(7, 'darkGray');
                    }

                    const total = DataCalculator.calculateBookingTotal(booking, data.settings?.serviceTypes);
                    const customerName = booking.customerName?.substring(0, 15) || 'N/A';

                    generator.pdf.text(booking.date || 'N/A', 25, generator.yPos);
                    generator.pdf.text(customerName, 45, generator.yPos);
                    generator.pdf.text(`${booking.services?.length || 0} services`, 85, generator.yPos);
                    generator.pdf.text('$' + total.toFixed(2), 130, generator.yPos);
                    generator.pdf.text(booking.status || 'N/A', 160, generator.yPos);
                    generator.yPos += 6;
                });

                if (totalBookings > maxBookings) {
                    generator.yPos += 5;
                    generator.setTextStyle(9, 'mediumGray');
                    generator.pdf.text(
                        `... and ${totalBookings - maxBookings} more bookings not shown`,
                        25,
                        generator.yPos
                    );
                }

                generator.yPos += 15;
            }

            static async addQuickStats(generator, data) {
                generator.checkPageBreak(50);
                generator.addSectionHeader('Quick Statistics');

                const stats = DataCalculator.calculateKPIs(data);
                const totalServices = Object.keys(data.settings?.serviceTypes || {}).length;
                const avgServicesPerBooking = stats.totalBookings > 0
                    ? data.bookings.reduce((sum, b) => sum + (b.services?.length || 0), 0) / stats.totalBookings
                    : 0;

                generator.setTextStyle(10, 'darkGray');

                const statsData = [
                    `Total Services Offered: ${totalServices}`,
                    `Average Services per Booking: ${avgServicesPerBooking.toFixed(1)}`,
                    `Most Popular Service: ${stats.popularService}`,
                    `Report Generated: ${new Date().toLocaleString()}`
                ];

                statsData.forEach(text => {
                    generator.pdf.text(text, 25, generator.yPos);
                    generator.yPos += 8;
                });

                generator.yPos += 15;
            }
        }

        // ============================================================================
        // EXPORT TEMPLATES
        // ============================================================================

        const ExportTemplates = {
            'kpis': {
                name: 'Key Performance Indicators',
                generate: ExportSections.addKPISection
            },
            'revenue-chart': {
                name: 'Revenue Chart',
                generate: ExportSections.addRevenueChart
            },
            'service-distribution': {
                name: 'Service Distribution',
                generate: ExportSections.addServiceDistribution
            },
            'bookings': {
                name: 'Booking Details',
                generate: ExportSections.addBookingsTable
            },
            'quick-stats': {
                name: 'Quick Statistics',
                generate: ExportSections.addQuickStats
            }
        };

        // ============================================================================
        // UI HELPER FUNCTIONS
        // ============================================================================

        function getFilterSummary() {
            const filters = [];
            
            // Get selected export items and their time ranges
            const selectedItems = getSelectedExportItems();
            const timeRanges = new Set();
            
            selectedItems.forEach(item => {
                if (item.timeRange) {
                    timeRanges.add(item.timeRange);
                }
            });
            
            // Add time range filters
            if (timeRanges.size > 0) {
                const rangeText = Array.from(timeRanges).map(range => {
                    switch(range) {
                        case 'this-week': return 'This Week';
                        case 'this-month': return 'This Month';
                        case 'last-month': return 'Last Month';
                        case 'last-3-months': return 'Last 3 Months';
                        case 'custom': return 'Custom Range';
                        default: return range;
                    }
                }).join(', ');
                filters.push(`Time Range: ${rangeText}`);
            }
            
            // Add custom date ranges if any
            const customRanges = selectedItems.filter(item => 
                item.timeRange === 'custom' && item.options?.customStart && item.options?.customEnd
            );
            
            if (customRanges.length > 0) {
                const customRange = customRanges[0];
                filters.push(`Custom Dates: ${customRange.options.customStart} to ${customRange.options.customEnd}`);
            }
            
            // Add selected sections
            const sections = selectedItems.map(item => {
                const template = ExportTemplates[item.type];
                return template ? template.name : item.type;
            });
            
            if (sections.length > 0) {
                filters.push(`Sections: ${sections.join(', ')}`);
            }
            
            // Debug logging
            console.log('Filter summary:', filters);
            console.log('Selected items:', selectedItems);
            
            return filters;
        }

        function toggleExportSection(sectionName) {
            const optionsDiv = document.getElementById(sectionName + 'Options');
            const checkbox = document.querySelector(`input[value="${sectionName}"]`);
            
            if (optionsDiv && checkbox) {
                optionsDiv.style.display = checkbox.checked ? 'block' : 'none';
            }
        }

        function handleBookingsTimeRangeChange() {
            const timeRange = document.getElementById('bookingsTimeRange')?.value;
            const customDateRange = document.getElementById('customDateRange');
            
            if (customDateRange) {
                customDateRange.style.display = timeRange === 'custom' ? 'block' : 'none';
            }
        }

        function getSelectedExportItems() {
            const checkboxes = document.querySelectorAll('input[name="exportItem"]:checked');
            const items = [];

            checkboxes.forEach(checkbox => {
                const item = { type: checkbox.value, timeRange: null, options: {} };
                
                // Get time range for specific sections
                const timeRangeMap = {
                    'bookings': 'bookingsTimeRange',
                    'revenue-chart': 'revenueTimeRange',
                    'service-distribution': 'serviceTimeRange'
                };

                const timeRangeId = timeRangeMap[checkbox.value];
                if (timeRangeId) {
                    item.timeRange = document.getElementById(timeRangeId)?.value;
                    
                    if (item.timeRange === 'custom') {
                        item.options.customStart = document.getElementById('startDate')?.value;
                        item.options.customEnd = document.getElementById('endDate')?.value;
                    }
                }
                
                items.push(item);
            });

            return items;
        }

        // ============================================================================
        // MAIN EXPORT FUNCTION
        // ============================================================================

        async function generateEnhancedPDF() {
            try {
                if (!window.jspdf) {
                    throw new Error('jsPDF library not loaded');
                }

                if (typeof showToast === 'function') {
                    showToast('Generating PDF report...', 'info');
                }

                const selectedItems = getSelectedExportItems();
                const filters = getFilterSummary();
                
                const generator = new PDFGenerator(window.jspdf.jsPDF, filters);
                await generator.addHeader();

                for (const item of selectedItems) {
                    const template = ExportTemplates[item.type];
                    
                    if (!template) continue;

                    try {
                        // Filter data by time range if applicable
                        let dataToUse = window.filteredData || {};
                        
                        if (item.timeRange) {
                            dataToUse = TimeRangeFilter.filterDataByRange(
                                dataToUse,
                                item.timeRange,
                                item.options?.customStart,
                                item.options?.customEnd
                            );
                        }

                        await template.generate(generator, dataToUse, item.options);
                    } catch (error) {
                        console.error(`Error generating ${template.name}:`, error);
                        if (typeof showToast === 'function') {
                            showToast(`Error generating ${template.name}`, 'error');
                        }
                    }
                }

                generator.save();

                if (typeof showToast === 'function') {
                    showToast('PDF report generated successfully!', 'success');
                }
                
                if (typeof closeModal === 'function') {
                    closeModal('exportModal');
                }
            } catch (error) {
                console.error('PDF generation error:', error);
                if (typeof showToast === 'function') {
                    showToast('Error generating PDF: ' + error.message, 'error');
                }
            }
        }

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================

        function addExportTemplate(templateId, config) {
            if (!config.name || typeof config.generate !== 'function') {
                console.error('Invalid template configuration');
                return false;
            }
            
            ExportTemplates[templateId] = config;
            console.log(`Added export template: ${templateId}`);
            return true;
        }

        function printDashboard() {
            window.print();
            closeModal('exportModal');
        }

        function exportJSON() {
            const dataStr = JSON.stringify(filteredData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'dashboard-export.json';
            link.click();
            showToast('JSON exported successfully!', 'success');
            closeModal('exportModal');
        }

        function exportBookings() {
            // Sort bookings by date (newest first) before exporting
            const sortedBookings = [...filteredData.bookings].sort((a, b) => {
                const dateTimeA = new Date(a.date.replace(/\//g, '-') + ' ' + a.time);
                const dateTimeB = new Date(b.date.replace(/\//g, '-') + ' ' + b.time);
                return dateTimeB - dateTimeA; // Descending order (newest first)
            });
            const dataStr = JSON.stringify(sortedBookings, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'bookings-export.json';
            link.click();
            showToast('Bookings exported!', 'success');
        }


        function getTimeRangeData(timeRange, data) {
            const now = new Date();
            let startDate, endDate;

            switch (timeRange) {
                case 'this-week':
                    startDate = new Date(now.setDate(now.getDate() - now.getDay()));
                    endDate = new Date(now.setDate(now.getDate() - now.getDay() + 6));
                    break;
                case 'this-month':
                    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                    break;
                case 'last-month':
                    startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                    endDate = new Date(now.getFullYear(), now.getMonth(), 0);
                    break;
                case 'last-3-months':
                    startDate = new Date(now.getFullYear(), now.getMonth() - 3, 1);
                    endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                    break;
                case 'custom':
                    const startInput = document.getElementById('startDate');
                    const endInput = document.getElementById('endDate');
                    if (startInput && endInput && startInput.value && endInput.value) {
                        startDate = new Date(startInput.value);
                        endDate = new Date(endInput.value);
                    } else {
                        return data; // Return all data if custom dates not set
                    }
                    break;
                default:
                    return data;
            }

            return {
                ...data,
                bookings: data.bookings.filter(booking => {
                    const bookingDate = new Date(booking.date);
                    return bookingDate >= startDate && bookingDate <= endDate;
                })
            };
        }

        async function generateEnhancedPDF() {
            showToast('Generating enhanced PDF report...', 'info');
            
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            
            // Professional styling - black, white, gray only
            const colors = {
                black: [0, 0, 0],
                darkGray: [64, 64, 64],
                mediumGray: [128, 128, 128],
                lightGray: [192, 192, 192],
                white: [255, 255, 255]
            };

            let yPos = 20;
            let pageNumber = 1;

            // Header with Logo (placeholder for now - will be replaced with actual logo)
            pdf.setFillColor(...colors.lightGray);
            pdf.rect(15, 10, 180, 25, 'F');
            
            // Logo placeholder - in real implementation, load actual logo.png
            pdf.setFillColor(...colors.darkGray);
            pdf.rect(20, 15, 20, 15, 'F');
            
            // Report title
            pdf.setTextColor(...colors.black);
            pdf.setFontSize(18);
            pdf.text('Venus Dashboard Report', 50, 20);
            
            // Date generated
            pdf.setFontSize(10);
            pdf.setTextColor(...colors.mediumGray);
            pdf.text(`Generated: ${new Date().toLocaleString()}`, 50, 26);
            
            yPos = 45;

            // Get selected export options
            const selectedItems = Array.from(document.querySelectorAll('input[name="exportItem"]:checked'))
                .map(input => input.value);

            // Add logo to PDF (if logo.png exists)
            try {
                const logoImg = await loadLogoImage();
                pdf.addImage(logoImg, 'PNG', 20, 15, 20, 15);
                console.log('Logo loaded successfully');
            } catch (error) {
                console.log('Logo not found, using placeholder');
                // Keep the placeholder that was already drawn
            }

            // KPI Summary Section
            if (selectedItems.includes('kpis')) {
                yPos = await addKPISection(pdf, yPos, colors);
                if (yPos > 270) {
                    pdf.addPage();
                    yPos = 20;
                }
            }

            // Revenue Chart Section
            if (selectedItems.includes('revenue-chart')) {
                const timeRange = document.getElementById('revenueTimeRange').value;
                const chartData = getTimeRangeData(timeRange, filteredData);
                yPos = await addRevenueChartSection(pdf, yPos, colors, chartData);
                if (yPos > 270) {
                    pdf.addPage();
                    yPos = 20;
                }
            }

            // Service Distribution Section
            if (selectedItems.includes('service-distribution')) {
                const timeRange = document.getElementById('serviceTimeRange').value;
                const chartData = getTimeRangeData(timeRange, filteredData);
                yPos = await addServiceDistributionSection(pdf, yPos, colors, chartData);
                if (yPos > 270) {
                    pdf.addPage();
                    yPos = 20;
                }
            }

            // Bookings Table Section
            if (selectedItems.includes('bookings')) {
                const timeRange = document.getElementById('bookingsTimeRange').value;
                const chartData = getTimeRangeData(timeRange, filteredData);
                yPos = await addBookingsTableSection(pdf, yPos, colors, chartData);
            }

            // Quick Stats Section
            if (selectedItems.includes('quick-stats')) {
                yPos = await addQuickStatsSection(pdf, yPos, colors);
            }

            // Footer
            addFooter(pdf, colors, pageNumber);

            pdf.save('venus-dashboard-report.pdf');
            showToast('Enhanced PDF report generated successfully!', 'success');
            closeModal('exportModal');
        }

        async function addKPISection(pdf, yPos, colors) {
            pdf.setFontSize(14);
            pdf.setTextColor(...colors.black);
            pdf.text('Key Performance Indicators', 20, yPos);
            yPos += 10;

            // Draw separator line
            pdf.setDrawColor(...colors.lightGray);
            pdf.line(20, yPos, 190, yPos);
            yPos += 8;

            const kpis = calculateKPIs(filteredData);
            
            pdf.setFontSize(10);
            pdf.setTextColor(...colors.black);
            
            // KPI Grid layout
            const kpiItems = [
                [`Total Revenue: $${kpis.totalRevenue.toLocaleString()}`, `Total Bookings: ${kpis.totalBookings}`],
                [`Average Booking Value: $${kpis.avgBookingValue.toFixed(2)}`, `Most Popular Service: ${kpis.popularService}`]
            ];

            kpiItems.forEach(row => {
                row.forEach((item, index) => {
                    const xPos = 20 + (index * 85);
                    pdf.text(item, xPos, yPos);
                });
                yPos += 8;
            });

            return yPos + 15;
        }

        async function addRevenueChartSection(pdf, yPos, colors, data) {
            pdf.setFontSize(14);
            pdf.setTextColor(...colors.black);
            pdf.text('Revenue Analysis', 20, yPos);
            yPos += 10;

            // Draw separator line
            pdf.setDrawColor(...colors.lightGray);
            pdf.line(20, yPos, 190, yPos);
            yPos += 8;

            // Try to export chart if available, otherwise use table
            try {
                const chartCanvas = document.querySelector('canvas[id*="revenue"]');
                if (chartCanvas) {
                    yPos = await exportChartToPDF(pdf, chartCanvas, yPos, colors);
                    yPos += 10;
                }
            } catch (error) {
                console.log('Chart export failed, using table fallback');
            }

            // Revenue table with actual calculated data
            pdf.setFontSize(9);
            pdf.setTextColor(...colors.darkGray);
            
            // Table header
            pdf.setFillColor(...colors.lightGray);
            pdf.rect(20, yPos - 5, 170, 8, 'F');
            pdf.setTextColor(...colors.black);
            pdf.text('Date', 25, yPos);
            pdf.text('Revenue', 80, yPos);
            pdf.text('Bookings', 130, yPos);
            yPos += 10;

            // Calculate actual revenue data from bookings
            const revenueData = calculateRevenueByDate(data.bookings);
            const maxRows = Math.min(revenueData.length, 15); // Limit for performance
            
            for (let i = 0; i < maxRows; i++) {
                if (yPos > 270) break;
                
                const row = revenueData[i];
                pdf.setTextColor(...colors.darkGray);
                pdf.text(row.date, 25, yPos);
                pdf.text('$' + row.revenue.toLocaleString(), 80, yPos);
                pdf.text(row.bookings.toString(), 130, yPos);
                yPos += 7;
            }

            if (revenueData.length > maxRows) {
                yPos += 5;
                pdf.setTextColor(...colors.mediumGray);
                pdf.text(`... and ${revenueData.length - maxRows} more days`, 25, yPos);
                yPos += 8;
            }

            return yPos + 15;
        }

        async function exportChartToPDF(pdf, canvas, yPos, colors) {
            return new Promise((resolve) => {
                try {
                    // Convert canvas to image
                    const imgData = canvas.toDataURL('image/png');
                    
                    // Calculate dimensions to fit in PDF
                    const maxWidth = 170;
                    const maxHeight = 80;
                    const aspectRatio = canvas.width / canvas.height;
                    
                    let width = maxWidth;
                    let height = width / aspectRatio;
                    
                    if (height > maxHeight) {
                        height = maxHeight;
                        width = height * aspectRatio;
                    }
                    
                    // Add image to PDF
                    pdf.addImage(imgData, 'PNG', 20, yPos, width, height);
                    resolve(yPos + height + 10);
                } catch (error) {
                    console.error('Chart export error:', error);
                    resolve(yPos);
                }
            });
        }

        function calculateRevenueByDate(bookings) {
            const revenueByDate = {};
            
            bookings.forEach(booking => {
                const date = booking.date;
                if (!revenueByDate[date]) {
                    revenueByDate[date] = { revenue: 0, bookings: 0 };
                }
                
                // Calculate total for this booking
                let total = 0;
                booking.services.forEach(serviceId => {
                    const service = filteredData.settings.serviceTypes[serviceId];
                    if (service) total += service.price;
                });
                
                revenueByDate[date].revenue += total;
                revenueByDate[date].bookings += 1;
            });
            
            // Convert to array and sort by date
            return Object.entries(revenueByDate)
                .map(([date, data]) => ({ date, ...data }))
                .sort((a, b) => new Date(a.date) - new Date(b.date))
                .slice(-15); // Last 15 days for performance
        }

        async function addServiceDistributionSection(pdf, yPos, colors, data) {
            pdf.setFontSize(14);
            pdf.setTextColor(...colors.black);
            pdf.text('Service Distribution', 20, yPos);
            yPos += 10;

            // Draw separator line
            pdf.setDrawColor(...colors.lightGray);
            pdf.line(20, yPos, 190, yPos);
            yPos += 8;

            // Service popularity table
            pdf.setFontSize(9);
            
            // Table header
            pdf.setFillColor(...colors.lightGray);
            pdf.rect(20, yPos - 5, 170, 8, 'F');
            pdf.setTextColor(...colors.black);
            pdf.text('Service', 25, yPos);
            pdf.text('Count', 100, yPos);
            pdf.text('Percentage', 150, yPos);
            yPos += 10;

            // Calculate service distribution
            const serviceCounts = {};
            data.bookings.forEach(booking => {
                booking.services.forEach(serviceId => {
                    serviceCounts[serviceId] = (serviceCounts[serviceId] || 0) + 1;
                });
            });

            const totalServices = Object.values(serviceCounts).reduce((sum, count) => sum + count, 0);
            const sortedServices = Object.entries(serviceCounts)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 8); // Top 8 services

            sortedServices.forEach(([serviceId, count]) => {
                const service = data.settings.serviceTypes[serviceId];
                const percentage = ((count / totalServices) * 100).toFixed(1);
                
                pdf.setTextColor(...colors.darkGray);
                pdf.text(service ? service.name : serviceId, 25, yPos);
                pdf.text(count.toString(), 100, yPos);
                pdf.text(percentage + '%', 150, yPos);
                yPos += 7;
            });

            return yPos + 15;
        }
        async function addBookingsTableSection(pdf, yPos, colors, data) {
            pdf.setFontSize(14);
            pdf.setTextColor(...colors.black);
            pdf.text('Booking Details', 20, yPos);
            yPos += 10;

            // Draw separator line
            pdf.setDrawColor(...colors.lightGray);
            pdf.line(20, yPos, 190, yPos);
            yPos += 8;

            // Performance optimization: Limit data processing for large datasets
            const totalBookings = data.bookings.length;
            const maxRowsPerPage = 25;
            const maxTotalRows = Math.min(totalBookings, 100); // Limit to 100 rows for performance
            
            // Show summary if dataset is large
            if (totalBookings > maxTotalRows) {
                pdf.setFontSize(9);
                pdf.setTextColor(...colors.mediumGray);
                pdf.text(`Showing ${maxTotalRows} of ${totalBookings} bookings (performance optimized)`, 25, yPos);
                yPos += 8;
            }

            // Table header
            pdf.setFontSize(8);
            pdf.setFillColor(...colors.lightGray);
            pdf.rect(20, yPos - 5, 170, 8, 'F');
            pdf.setTextColor(...colors.black);
            
            const headers = ['Date', 'Customer', 'Services', 'Total', 'Status'];
            const headerPositions = [25, 45, 85, 130, 160];
            
            headers.forEach((header, index) => {
                pdf.text(header, headerPositions[index], yPos);
            });
            yPos += 10;

            // Process bookings in batches for better performance
            // Sort bookings by date (newest first) before processing
            const sortedBookings = [...data.bookings].sort((a, b) => {
                const dateTimeA = new Date(a.date.replace(/\//g, '-') + ' ' + a.time);
                const dateTimeB = new Date(b.date.replace(/\//g, '-') + ' ' + b.time);
                return dateTimeB - dateTimeA; // Descending order (newest first)
            });
            const bookingsToProcess = sortedBookings.slice(0, maxTotalRows);
            pdf.setFontSize(7);
            
            for (let i = 0; i < bookingsToProcess.length; i++) {
                if (yPos > 270) {
                    pdf.addPage();
                    yPos = 20;
                    // Re-add header on new page
                    pdf.setFillColor(...colors.lightGray);
                    pdf.rect(20, yPos - 5, 170, 8, 'F');
                    pdf.setTextColor(...colors.black);
                    pdf.setFontSize(8);
                    headers.forEach((header, index) => {
                        pdf.text(header, headerPositions[index], yPos);
                    });
                    yPos += 10;
                    pdf.setFontSize(7);
                }

                const booking = bookingsToProcess[i];
                
                // Optimize service total calculation
                let total = 0;
                const serviceTypes = data.settings.serviceTypes;
                for (const serviceId of booking.services) {
                    const service = serviceTypes[serviceId];
                    if (service) total += service.price;
                }

                pdf.setTextColor(...colors.darkGray);
                pdf.text(booking.date, 25, yPos);
                pdf.text(booking.customerName.substring(0, 15), 45, yPos);
                pdf.text(booking.services.length + ' services', 85, yPos);
                pdf.text('$' + total, 130, yPos);
                pdf.text(booking.status, 160, yPos);
                yPos += 6;
            }

            // Show remaining count if applicable
            if (totalBookings > maxTotalRows) {
                yPos += 5;
                pdf.setTextColor(...colors.mediumGray);
                pdf.text(`... and ${totalBookings - maxTotalRows} more bookings not shown for performance`, 25, yPos);
                yPos += 8;
            }

            return yPos + 15;
        }

        async function addQuickStatsSection(pdf, yPos, colors) {
            pdf.setFontSize(14);
            pdf.setTextColor(...colors.black);
            pdf.text('Quick Statistics', 20, yPos);
            yPos += 10;

            // Draw separator line
            pdf.setDrawColor(...colors.lightGray);
            pdf.line(20, yPos, 190, yPos);
            yPos += 8;

            const stats = calculateKPIs(filteredData);
            
            pdf.setFontSize(10);
            pdf.setTextColor(...colors.darkGray);
            
            const statsItems = [
                `Total Services Offered: ${Object.keys(filteredData.settings.serviceTypes).length}`,
                `Average Services per Booking: ${(stats.totalBookings > 0 ? filteredData.bookings.reduce((sum, b) => sum + b.services.length, 0) / stats.totalBookings : 0).toFixed(1)}`,
                `Most Popular Service: ${stats.popularService}`,
                `Report Generated: ${new Date().toLocaleString()}`
            ];

            statsItems.forEach(item => {
                pdf.text(item, 25, yPos);
                yPos += 8;
            });

            return yPos + 15;
        }

        function addFooter(pdf, colors, pageNumber) {
            // Footer line
            pdf.setDrawColor(...colors.lightGray);
            pdf.line(20, 285, 190, 285);
            
            // Footer text
            pdf.setFontSize(8);
            pdf.setTextColor(...colors.mediumGray);
            pdf.text('Venus Dashboard Report - Confidential', 20, 290);
            pdf.text(`Page ${pageNumber}`, 180, 290);
        }

        // Enhanced Export Helper Functions
        function handleBookingsTimeRangeChange() {
            const timeRange = document.getElementById('bookingsTimeRange').value;
            const customDateRange = document.getElementById('customDateRange');
            
            if (timeRange === 'custom') {
                customDateRange.style.display = 'block';
            } else {
                customDateRange.style.display = 'none';
            }
        }

        async function loadLogoImage() {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error('Logo not found'));
                img.src = 'logo.png';
            });
        }

        // Widget Management
        function addWidget(widgetType) {
            console.log('User explicitly adding widget:', widgetType, 'to layout:', currentCustomLayout);
            
            if (currentView !== 'custom' || !currentCustomLayout) {
                showToast('Create a custom layout first to add widgets', 'warning');
                closeModal('addWidgetModal');
                return;
            }

            const grid = document.getElementById('dashboardGrid');
            
            // Remove empty state if it exists
            const emptyState = grid.querySelector('.custom-empty-state');
            if (emptyState) {
                emptyState.remove();
            }

            let widgetHTML = '';
            // Generate layout-specific widget ID to prevent collisions between custom layouts
            const layoutPrefix = currentCustomLayout ? `layout-${currentCustomLayout}-` : '';
            const widgetId = `widget-${layoutPrefix}${widgetType}-${Date.now()}`;

            switch(widgetType) {
                case 'revenue-chart':
                    widgetHTML = `
                        <div class="widget widget-medium" id="${widgetId}">
                            <div class="widget-header">
                                <h3 class="widget-title">Revenue Chart</h3>
                                <div class="widget-actions no-print">
                                    <button class="widget-btn" onclick="removeWidget('${widgetId}')">🗑️</button>
                                    <button class="widget-btn" onclick="refreshWidget('${widgetId}')">🔄</button>
                                    <button class="widget-btn" onclick="expandWidget('${widgetId.replace('widget-', '')}')" title="Toggle expand/collapse">⛶</button>
                                </div>
                            </div>
                            <div class="booking-list-filter-status" id="filter-status-${widgetId}">
                                <!-- Filter status will be displayed here -->
                            </div>
                            <div class="chart-container">
                                <canvas id="chart-${widgetId}"></canvas>
                            </div>
                            <div class="resize-handle"></div>
                        </div>
                    `;
                    break;
                case 'service-distribution':
                    widgetHTML = `
                        <div class="widget widget-medium" id="${widgetId}">
                            <div class="widget-header">
                                <h3 class="widget-title">Service Distribution</h3>
                                <div class="widget-actions no-print">
                                    <button class="widget-btn" onclick="removeWidget('${widgetId}')">🗑️</button>
                                    <button class="widget-btn" onclick="refreshWidget('${widgetId}')">🔄</button>
                                </div>
                            </div>
                            <div class="booking-list-filter-status" id="filter-status-${widgetId}">
                                <!-- Filter status will be displayed here -->
                            </div>
                            <div class="chart-container">
                                <canvas id="chart-${widgetId}"></canvas>
                            </div>
                            <div class="resize-handle"></div>
                        </div>
                    `;
                    break;
                case 'add-widget':
                    widgetHTML = `
                        <div class="widget widget-medium" id="${widgetId}">
                            <div class="add-widget-widget" onclick="openModal('addWidgetModal')" title="Add Widget">
                                <span class="add-widget-icon">➕</span>
                            </div>
                        </div>
                    `;
                    break;
                case 'bookings':
                    // Determine initial size based on saved state
                    const initialMode = loadBookingWidgetState(widgetId);
                    const initialSizeClass = initialMode === 'large' ? 'widget-full' : 'widget-medium';
                    
                    widgetHTML = `
                        <div class="widget ${initialSizeClass}" id="${widgetId}">
                            <div class="widget-header">
                                <h3 class="widget-title">Bookings</h3>
                                <div class="widget-actions no-print">
                                    <button class="widget-btn" onclick="toggleBookingWidgetMode('${widgetId}')" title="Toggle view mode">⛶</button>
                                    <button class="widget-btn" onclick="removeWidget('${widgetId}')">🗑️</button>
                                    <button class="widget-btn" onclick="refreshWidget('${widgetId}')">🔄</button>
                                </div>
                            </div>
                            <div class="booking-list-filter-status" id="booking-list-filter-status-${widgetId}">
                                <!-- Filter status will be displayed here -->
                            </div>
                            <div id="table-${widgetId}"></div>
                        </div>
                    `;
                    break;
                case 'calendar':
                    widgetHTML = `
                        <div class="widget widget-full" id="${widgetId}">
                            <div class="widget-header">
                                <h3 class="widget-title">Booking Calendar</h3>
                                <div class="widget-actions no-print">
                                    <button class="widget-btn" onclick="removeWidget('${widgetId}')">🗑️</button>
                                    <button class="widget-btn" onclick="refreshWidget('${widgetId}')">🔄</button>
                                </div>
                            </div>
                            <div class="calendar-container" id="calendar-${widgetId}">
                                <div class="calendar-header">
                                    <div class="calendar-nav">
                                        <button class="btn btn-secondary calendar-nav-btn" onclick="changeCalendarView('${widgetId}', 'prev')">‹</button>
                                        <h4 class="calendar-title" id="calendar-title-${widgetId}">October 2024</h4>
                                        <button class="btn btn-secondary calendar-nav-btn" onclick="changeCalendarView('${widgetId}', 'next')">›</button>
                                    </div>
                                    <div class="calendar-view-toggle">
                                        <button class="btn btn-sm btn-secondary calendar-view-btn active" data-view="month" onclick="switchCalendarView('${widgetId}', 'month')">Month</button>
                                        <button class="btn btn-sm btn-secondary calendar-view-btn" data-view="week" onclick="switchCalendarView('${widgetId}', 'week')">Week</button>
                                        <button class="btn btn-sm btn-secondary calendar-view-btn" data-view="day" onclick="switchCalendarView('${widgetId}', 'day')">Day</button>
                                    </div>
                                </div>
                                <div class="calendar-filter-status" id="calendar-filter-status-${widgetId}">
                                    <!-- Filter status will be displayed here -->
                                </div>
                                <div class="calendar-content" id="calendar-content-${widgetId}">
                                    <!-- Calendar will be rendered here -->
                                </div>
                                <div class="calendar-legend">
                                    <div class="legend-item">
                                        <span class="legend-color pending"></span>
                                        <span>Pending</span>
                                    </div>
                                    <div class="legend-item">
                                        <span class="legend-color confirmed"></span>
                                        <span>Confirmed</span>
                                    </div>
                                    <div class="legend-item">
                                        <span class="legend-color cancelled"></span>
                                        <span>Cancelled</span>
                                    </div>
                                </div>
                            </div>
                            <div class="resize-handle"></div>
                        </div>
                    `;
                    break;
            }

            // Find the Add Widget widget and insert before it, or append to end if no Add Widget widget exists
            const addWidgetElement = grid.querySelector('.add-widget-widget');
            if (addWidgetElement) {
                // Insert before the Add Widget widget to keep it at the end
                addWidgetElement.closest('.widget').insertAdjacentHTML('beforebegin', widgetHTML);
            } else {
                // No Add Widget widget exists, append to end
                grid.insertAdjacentHTML('beforeend', widgetHTML);
            }
            
            // Initialize the widget content
            setTimeout(() => {
                initializeCustomWidget(widgetId, widgetType);
                initializeDraggableWidgets();
                saveCurrentCustomLayout(); // Save to custom layout
                triggerAutoSave(); // Auto-save when widget is added
                
                // Auto-add Add Widget widget after adding a widget
                autoAddWidgetWidget();
            }, 100);

            showToast(`${widgetType.replace('-', ' ')} widget added!`, 'success');
            closeModal('addWidgetModal');
        }

        function initializeCustomWidget(widgetId, widgetType) {
            const canvas = document.getElementById(`chart-${widgetId}`);
            const tableContainer = document.getElementById(`table-${widgetId}`);
            // Legacy reference removed - now handled by createUnifiedBookingTable
            const statsContainer = document.getElementById(`stats-${widgetId}`);
            const calendarContainer = document.getElementById(`calendar-content-${widgetId}`);
            
            if (canvas) {
                const ctx = canvas.getContext('2d');
                
            switch(widgetType) {
                    case 'revenue-over-time':
                        // Legacy mapping - convert to new unified Revenue Chart
                        console.warn('Legacy widget type "revenue-over-time" detected in widget initialization. Converting to unified "revenue-chart". Please update your layout.');
                        // Fall through to revenue-chart case
                    case 'revenue-chart':
                        createCustomRevenueChart(ctx, widgetId);
                        break;
                    case 'service-distribution':
                        createCustomServicesChart(ctx, widgetId);
                        break;
                    case 'timeline':
                        createCustomTimelineChart(ctx, widgetId);
                        break;
                }
            }
            
            if (tableContainer) {
                switch(widgetType) {
                    case 'bookings':
                        // Initialize unified booking widget with saved state or default to large
                        const savedMode = loadBookingWidgetState(widgetId);
                        createUnifiedBookingTable(tableContainer, widgetId, savedMode);
                        updateBookingListFilterStatus(widgetId);
                        break;
                }
            }
            
            if (calendarContainer) {
                switch(widgetType) {
                    case 'calendar':
                        initializeCalendarWidget(widgetId);
                        break;
                }
            }
            
            if (statsContainer) {
                renderCustomStats(statsContainer);
            }
        }

        function createCustomRevenueChart(ctx, widgetId) {
            const revenueByDate = {};
            filteredData.bookings.forEach(booking => {
                const date = booking.date;
                if (!revenueByDate[date]) revenueByDate[date] = 0;
                
                booking.services.forEach(serviceId => {
                    const service = filteredData.settings.serviceTypes[serviceId];
                    if (service) {
                        revenueByDate[date] += service.price;
                    }
                });
            });

            const dates = Object.keys(revenueByDate).sort();
            const revenues = dates.map(date => revenueByDate[date]);

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: [{
                        label: 'Daily Revenue ($)',
                        data: revenues,
                        borderColor: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim(),
                        backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim() + '20',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value;
                                }
                            }
                        }
                    }
                }
            });
            
            // Update filter status display
            updateRevenueFilterStatus(widgetId);
        }

        function createCustomServicesChart(ctx, widgetId) {
            const serviceCount = {};
            filteredData.bookings.forEach(booking => {
                booking.services.forEach(serviceId => {
                    const service = filteredData.settings.serviceTypes[serviceId];
                    if (service) {
                        serviceCount[service.name] = (serviceCount[service.name] || 0) + 1;
                    }
                });
            });

            const labels = Object.keys(serviceCount);
            const data = Object.values(serviceCount);

            new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: [
                            '#3498db', '#2ecc71', '#f39c12', '#e74c3c', '#9b59b6',
                            '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#16a085'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom' }
                    }
                }
            });
            
            // Update filter status display
            updateServicesFilterStatus(widgetId);
        }

        function createCustomTimelineChart(ctx, widgetId) {
            const bookingsByDate = {};
            filteredData.bookings.forEach(booking => {
                const date = booking.date;
                bookingsByDate[date] = (bookingsByDate[date] || 0) + 1;
            });

            const dates = Object.keys(bookingsByDate).sort();
            const counts = dates.map(date => bookingsByDate[date]);

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: dates,
                    datasets: [{
                        label: 'Bookings per Day',
                        data: counts,
                        backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--accent-secondary').trim(),
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { stepSize: 1 }
                        }
                    }
                }
            });
        }

        function createUnifiedBookingTable(container, widgetId, mode = 'small') {
            if (!container) return;
            
            // Store the current mode for this widget
            container.dataset.mode = mode;
            
            // Sort bookings by date and time (newest first)
            const sortedBookings = [...filteredData.bookings].sort((a, b) => {
                const dateTimeA = new Date(a.date.replace(/\//g, '-') + ' ' + a.time);
                const dateTimeB = new Date(b.date.replace(/\//g, '-') + ' ' + b.time);
                return dateTimeB - dateTimeA; // Descending order (newest first)
            });
            
            const bookings = mode === 'small' ? sortedBookings.slice(0, 10) : sortedBookings;
            const isRestricted = restrictedMode;

            let tableHtml = `
                <div class="table-responsive">
                    <table class="data-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Customer</th>
                            ${mode === 'large' ? '<th>Services</th><th>Car</th>' : ''}
                            <th>Total</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            let mobileCardsHtml = `
                <div class="mobile-booking-cards">
            `;

            bookings.forEach(booking => {
                let total = 0;
                const serviceNames = booking.services.map(serviceId => {
                    const service = filteredData.settings.serviceTypes[serviceId];
                    if (service) {
                        total += service.price;
                        return service.name;
                    }
                    return serviceId;
                });

                // Desktop table row - make it clickable
                if (mode === 'small') {
                    // Small mode: Date, Customer, Total, Status (no services column)
                    tableHtml += `
                        <tr onclick="showBookingDetails('${booking.id}')" style="cursor: pointer;" title="Click to view details">
                            <td>${booking.date} ${booking.time}</td>
                            <td>
                                <div><strong>${booking.customerName}</strong></div>
                                <div style="font-size: 0.85rem; color: var(--text-secondary);">${isRestricted ? '••••••••@•••••••' : booking.email}</div>
                            </td>
                            <td><strong>${isRestricted ? '••••' : '$' + total}</strong></td>
                            <td><span class="status-badge status-${booking.status}">${booking.status}</span></td>
                        </tr>
                    `;
                } else {
                    // Large mode: Date, Customer, Services, Car, Total, Status
                    tableHtml += `
                        <tr onclick="showBookingDetails('${booking.id}')" style="cursor: pointer;" title="Click to view details">
                            <td>${booking.date} ${booking.time}</td>
                            <td>
                                <div><strong>${booking.customerName}</strong></div>
                                <div style="font-size: 0.85rem; color: var(--text-secondary);">${isRestricted ? '••••••••@•••••••' : booking.email}</div>
                            </td>
                            <td>
                                <div class="service-pills">
                                    ${serviceNames.map(name => `<span class="service-pill">${name}</span>`).join('')}
                                </div>
                            </td>
                            <td>${booking.carDetails}</td>
                            <td><strong>${isRestricted ? '••••' : '$' + total}</strong></td>
                            <td><span class="status-badge status-${booking.status}">${booking.status}</span></td>
                        </tr>
                    `;
                }

                // Mobile card - make it clickable
                mobileCardsHtml += `
                    <div class="mobile-booking-card" onclick="showBookingDetails('${booking.id}')" style="cursor: pointer;" title="Click to view details">
                        <div class="mobile-booking-header">
                            <div class="mobile-booking-date">${booking.date} ${booking.time}</div>
                            <div class="mobile-booking-status status-${booking.status}">${booking.status}</div>
                        </div>
                        
                        <div class="mobile-booking-customer">
                            <div class="mobile-booking-customer-name">${booking.customerName}</div>
                            <div class="mobile-booking-customer-email">${isRestricted ? '••••••••@•••••••' : booking.email}</div>
                        </div>
                        
                        <div class="mobile-booking-details">
                            <div class="mobile-booking-detail mobile-booking-services">
                                <div class="mobile-booking-detail-label">Services</div>
                                <div class="mobile-booking-detail-value">
                                    <div class="service-pills">
                                        ${serviceNames.map(name => `<span class="service-pill">${name}</span>`).join('')}
                                    </div>
                                </div>
                            </div>
                            ${mode === 'large' ? `
                            <div class="mobile-booking-detail">
                                <div class="mobile-booking-detail-label">Car Details</div>
                                <div class="mobile-booking-detail-value">${booking.carDetails}</div>
                            </div>
                            ` : ''}
                        </div>
                        
                        <div class="mobile-booking-total">${isRestricted ? '••••' : '$' + total}</div>
                    </div>
                `;
            });

            // Handle empty data case
            if (bookings.length === 0) {
                const colspan = mode === 'small' ? '4' : '6';
                tableHtml += `
                    <tr>
                        <td colspan="${colspan}" style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">📅</div>
                            <div>No data available for ${getCurrentPeriodLabel(getCurrentFilters())}.</div>
                        </td>
                    </tr>
                `;
                
                mobileCardsHtml += `
                    <div class="mobile-booking-card" style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                        <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">📅</div>
                        <div>No data available for ${getCurrentPeriodLabel(getCurrentFilters())}.</div>
                    </div>
                `;
            }

            tableHtml += `
                    </tbody>
                    </table>
                </div>
            `;

            mobileCardsHtml += `
                </div>
            `;

            // Combine both layouts
            const finalHtml = tableHtml + mobileCardsHtml;
            container.innerHTML = finalHtml;
            
            // Enforce immediate masking in Restricted Mode without requiring a separate refresh
            if (restrictedMode) {
                // Mask any totals that slipped through due to dynamic DOM updates
                container.querySelectorAll('td strong, .mobile-booking-total').forEach(el => {
                    const text = el.textContent || '';
                    if (/\$/.test(text)) {
                        el.textContent = '••••';
                        el.classList.add('restricted-hidden');
                    }
                });
            }
        }

        function renderCustomBookingsTable(container) {
            // This function is kept for backward compatibility
            createCustomBookingTable(container, 'default');
        }

        // Legacy function removed - now handled by createUnifiedBookingTable

        function renderCustomStats(container) {
            const services = filteredData.settings.serviceTypes;
            const totalServices = Object.keys(services).length;
            const avgPrice = totalServices > 0 ? Object.values(services).reduce((sum, s) => sum + s.price, 0) / totalServices : 0;
            const maxAppointments = filteredData.settings.maxAppointmentsPerDay;
            const isRestricted = restrictedMode;

            container.innerHTML = `
                <div class="stat-item">
                    <div class="stat-label">Available Services</div>
                    <div class="stat-value">${isRestricted ? '••••' : totalServices}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Avg Service Price</div>
                    <div class="stat-value">${isRestricted ? '••••' : '$' + avgPrice.toFixed(2)}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Max Daily Appointments</div>
                    <div class="stat-value">${isRestricted ? '••••' : maxAppointments}</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Time Slots</div>
                    <div class="stat-value">${isRestricted ? '••••' : filteredData.settings.availableTimeSlots.length}</div>
                </div>
            `;
        }
        function removeWidget(widgetId) {
            const widget = document.getElementById(widgetId);
            if (widget) {
                widget.remove();
                saveCurrentCustomLayout(); // Save to custom layout
                triggerAutoSave(); // Auto-save when widget is removed
                showToast('Widget removed', 'success');
                
                // In custom layouts, always ensure Add Widget placeholder remains
                setTimeout(() => {
                    if (currentView === 'custom' && currentCustomLayout) {
                        ensureAddWidgetPlaceholder();
                    } else {
                        // Only in non-custom views, check if we need to remove Add Widget widget when no regular widgets remain
                        const grid = document.getElementById('dashboardGrid');
                        const remainingWidgets = grid.querySelectorAll('.widget');
                        const regularWidgets = Array.from(remainingWidgets).filter(w => 
                            !w.querySelector('.add-widget-widget')
                        );
                        
                        // If no regular widgets remain, remove Add Widget widget
                        if (regularWidgets.length === 0) {
                            const addWidgetWidget = grid.querySelector('.add-widget-widget');
                            if (addWidgetWidget) {
                                addWidgetWidget.closest('.widget').remove();
                                saveCurrentCustomLayout();
                                triggerAutoSave();
                                
                                // Update mobile UI
                                updateMobileUI();
                            }
                        }
                    }
                }, 100);
                
                // Show empty state if no widgets left
                const grid = document.getElementById('dashboardGrid');
                if (grid.children.length === 0) {
                    grid.innerHTML = `
                        <div class="custom-empty-state">
                            <div class="custom-empty-content">
                                <div class="custom-empty-icon">🎨</div>
                                <h3 class="custom-empty-title">Custom Dashboard</h3>
                                <p class="custom-empty-description">Start building your custom dashboard by adding widgets below.</p>
                                <button class="btn btn-primary custom-empty-button" onclick="openModal('addWidgetModal')">
                                    <span>➕</span> Add Your First Widget
                                </button>
                            </div>
                        </div>
                    `;
                }
            }
        }

        function setWidgetRefreshing(widgetId, isRefreshing) {
            const el = document.getElementById(widgetId);
            if (el) {
                el.classList.toggle('refreshing', isRefreshing);
            }
        }

        function refreshWidget(widgetId) {
            showToast(`Refreshing ${widgetId}...`, 'info');
            const fullWidgetId = widgetId.startsWith('widget-') ? widgetId : `widget-${widgetId}`;
            setWidgetRefreshing(fullWidgetId, true);
            
            // No automatic widget preservation - only refresh existing widgets
            
            // Handle specific widget refreshes
            if (widgetId === 'revenue' || /revenue/.test(widgetId)) {
                // Refresh Revenue Chart
                if (widgetId === 'revenue') {
                    // Main dashboard revenue widget
                    const container = document.querySelector('#widget-revenue .chart-container');
                    if (container) {
                        // Recreate canvas to guarantee fresh Chart.js animation
                        container.innerHTML = '<canvas id="revenueChart"></canvas>';
                        requestAnimationFrame(() => {
                            createRevenueChart();
                            updateRevenueFilterStatus('widget-revenue');
                        });
                    } else {
                        createRevenueChart();
                        updateRevenueFilterStatus('widget-revenue');
                    }
                } else {
                    // Custom revenue widget
                    const canvas = document.getElementById(`chart-${widgetId}`);
                    if (canvas) {
                        const container = canvas.parentElement;
                        if (container) {
                            container.innerHTML = `<canvas id="chart-${widgetId}"></canvas>`;
                            const newCanvas = document.getElementById(`chart-${widgetId}`);
                            requestAnimationFrame(() => {
                                const ctx = newCanvas.getContext('2d');
                                createCustomRevenueChart(ctx, widgetId);
                                updateRevenueFilterStatus(widgetId);
                            });
                        } else {
                            const ctx = canvas.getContext('2d');
                            createCustomRevenueChart(ctx, widgetId);
                            updateRevenueFilterStatus(widgetId);
                        }
                    }
                }
                if (restrictedMode) enableRestrictedMode();
                setTimeout(() => setWidgetRefreshing(fullWidgetId, false), 1100);
                return;
            } else if (widgetId === 'bookings' || widgetId === 'all-bookings') {
                // Refresh Bookings widget (unified)
                const bookingsWidget = document.querySelector('#widget-bookings, [id*="bookings"]');
                if (bookingsWidget) {
                    const tableContainer = document.querySelector('#table-widget-bookings, [id*="table-"][id*="bookings"]');
                    if (tableContainer) {
                        const currentMode = tableContainer.dataset.mode || 'large';
                        const widgetIdForRefresh = bookingsWidget.id || 'widget-bookings';
                        createUnifiedBookingTable(tableContainer, widgetIdForRefresh, currentMode);
                        updateBookingListFilterStatus(widgetIdForRefresh);
                    }
                }
                // Apply Restricted Mode after refresh
                if (restrictedMode) {
                    enableRestrictedMode();
                }
                setTimeout(() => setWidgetRefreshing(fullWidgetId, false), 500);
                return;
            } else if (widgetId.includes('bookings')) {
                // Refresh unified booking widget
                const tableContainer = document.getElementById(`table-${widgetId}`);
                if (tableContainer) {
                    const currentMode = tableContainer.dataset.mode || 'large';
                    createUnifiedBookingTable(tableContainer, widgetId, currentMode);
                    updateBookingListFilterStatus(widgetId);
                }
                // Apply Restricted Mode after refresh
                if (restrictedMode) {
                    enableRestrictedMode();
                }
                setTimeout(() => setWidgetRefreshing(fullWidgetId, false), 500);
                return;
            } else if (widgetId === 'timeline') {
                // Refresh timeline widget
                const container = document.querySelector('#widget-timeline .chart-container');
                if (container) {
                    container.innerHTML = '<canvas id="timelineChart"></canvas>';
                    requestAnimationFrame(() => {
                        createTimelineChart();
                    });
                } else {
                    createTimelineChart();
                }
                // Apply Restricted Mode after refresh
                if (restrictedMode) {
                    enableRestrictedMode();
                }
                setTimeout(() => setWidgetRefreshing(fullWidgetId, false), 1100);
                return;
            } else if (widgetId === 'stats' || /stats/.test(widgetId)) {
                // Refresh Stats widget
                if (widgetId === 'stats') {
                    // Main dashboard stats widget
                    renderStats();
                } else {
                    // Custom stats widget
                    const statsContainer = document.getElementById(`stats-${widgetId}`);
                    if (statsContainer) {
                        renderCustomStats(statsContainer);
                    }
                }
                // Apply Restricted Mode after refresh
                if (restrictedMode) {
                    enableRestrictedMode();
                }
                setTimeout(() => setWidgetRefreshing(fullWidgetId, false), 500);
                return;
            } else if (widgetId === 'services' || /service/.test(widgetId)) {
                // Refresh Service Distribution widget
                if (widgetId === 'services') {
                    // Main dashboard services widget
                    const container = document.querySelector('#widget-services .chart-container');
                    if (container) {
                        container.innerHTML = '<canvas id="servicesChart"></canvas>';
                        requestAnimationFrame(() => {
                            createServicesChart();
                            updateServicesFilterStatus('widget-services');
                        });
                    } else {
                        createServicesChart();
                        updateServicesFilterStatus('widget-services');
                    }
                } else {
                    // Custom services widget
                    const canvas = document.getElementById(`chart-${widgetId}`);
                    if (canvas) {
                        const container = canvas.parentElement;
                        if (container) {
                            container.innerHTML = `<canvas id="chart-${widgetId}"></canvas>`;
                            const newCanvas = document.getElementById(`chart-${widgetId}`);
                            requestAnimationFrame(() => {
                                const ctx = newCanvas.getContext('2d');
                                createCustomServicesChart(ctx, widgetId);
                                updateServicesFilterStatus(widgetId);
                            });
                        } else {
                            const ctx = canvas.getContext('2d');
                            createCustomServicesChart(ctx, widgetId);
                            updateServicesFilterStatus(widgetId);
                        }
                    }
                }
                // Apply Restricted Mode after refresh
                if (restrictedMode) {
                    enableRestrictedMode();
                }
                setTimeout(() => setWidgetRefreshing(fullWidgetId, false), 1100);
                return;
            }
            
            // Default behavior for other widgets (should rarely be used now)
            console.warn(`No specific refresh handler for widget: ${widgetId}. Falling back to full dashboard refresh.`);
            renderDashboard();
            
            // No automatic widget restoration - widgets must be explicitly added via Add Widget
            
            // Apply Restricted Mode after refresh
            if (restrictedMode) {
                enableRestrictedMode();
            }
            setWidgetRefreshing(fullWidgetId, false);
        }

        function expandWidget(widgetId) {
            // Handle both formats: 'revenue' -> 'widget-revenue' and full widget IDs
            const fullWidgetId = widgetId.startsWith('widget-') ? widgetId : `widget-${widgetId}`;
            const widget = document.getElementById(fullWidgetId);
            
            if (!widget) {
                console.warn('Widget not found for expand/collapse:', fullWidgetId);
                return;
            }
            
            const isExpanded = widget.classList.contains('widget-full');
            
            if (isExpanded) {
                widget.classList.remove('widget-full');
                widget.classList.add('widget-medium');
            } else {
                widget.classList.remove('widget-medium');
                widget.classList.add('widget-full');
            }
            
            // Save widget state to localStorage for persistence
            const widgetState = JSON.parse(localStorage.getItem('widgetStates') || '{}');
            widgetState[fullWidgetId] = {
                expanded: !isExpanded,
                lastUpdated: Date.now()
            };
            localStorage.setItem('widgetStates', JSON.stringify(widgetState));
            
            // Save to layout customizations for persistence across layout switches
            if (currentView === 'custom' && currentCustomLayout) {
                saveCurrentCustomLayout();
            }
        }
        
        function restoreWidgetStates() {
            const widgetState = JSON.parse(localStorage.getItem('widgetStates') || '{}');
            
            Object.keys(widgetState).forEach(widgetId => {
                const state = widgetState[widgetId];
                const widget = document.getElementById(widgetId);
                
                if (widget && state.expanded) {
                    widget.classList.remove('widget-medium');
                    widget.classList.add('widget-full');
                }
            });
        }
        
        function saveAllWidgetStates() {
            const allWidgetStates = {};
            
            // Save expand/collapse states for all widgets
            document.querySelectorAll('.widget').forEach(widget => {
                const isExpanded = widget.classList.contains('widget-full');
                if (isExpanded) {
                    allWidgetStates[widget.id] = {
                        expanded: true,
                        lastUpdated: Date.now()
                    };
                }
            });
            
            // Save booking widget states
            document.querySelectorAll('[id*="bookings"]').forEach(widget => {
                const tableContainer = document.getElementById(`table-${widget.id}`);
                if (tableContainer && tableContainer.dataset.mode) {
                    saveBookingWidgetState(widget.id, tableContainer.dataset.mode);
                }
            });
            
            localStorage.setItem('widgetStates', JSON.stringify(allWidgetStates));
        }
        
        function refreshDataContent() {
            // Save current widget states before any refresh
            saveAllWidgetStates();
            
            // Always refresh KPI cards regardless of view
            const kpis = calculateKPIs(filteredData);
            const currentFilters = getCurrentFilters();
            const improvements = calculateImprovements(filteredData, currentFilters);
            renderKPIs(kpis, improvements, currentFilters);
            
            // Refresh individual widgets without rebuilding the entire dashboard
            if (currentView === 'full') {
                // Refresh full view widgets
                createRevenueChart();
                createServicesChart();
                createTimelineChart();
                renderStats();
                
                // Refresh bookings widget while preserving its size
                const bookingsTable = document.getElementById('table-widget-bookings');
                if (bookingsTable) {
                    const currentMode = bookingsTable.dataset.mode || 'large';
                    createUnifiedBookingTable(bookingsTable, 'widget-bookings', currentMode);
                    updateBookingListFilterStatus('widget-bookings');
                }
            } else if (currentView === 'custom' && currentCustomLayout) {
                // Refresh custom layout widgets
                const savedWidgets = JSON.parse(localStorage.getItem(`customLayout_${currentCustomLayout}`) || '[]');
                
                savedWidgets.forEach(widgetData => {
                    const widgetId = widgetData.id;
                    
                    // Refresh bookings widgets
                    if (widgetData.type === 'bookings' || widgetData.type === 'all-bookings') {
                        const tableContainer = document.getElementById(`table-${widgetId}`);
                        if (tableContainer) {
                            const currentMode = tableContainer.dataset.mode || 'large';
                            createUnifiedBookingTable(tableContainer, widgetId, currentMode);
                            updateBookingListFilterStatus(widgetId);
                        }
                    }
                    
                    // Refresh stats widgets
                    if (widgetData.type === 'stats') {
                        const statsContainer = document.getElementById(`stats-${widgetId}`);
                        if (statsContainer) {
                            renderCustomStats(statsContainer);
                        }
                    }
                    
                    // Refresh other widget types
                    initializeCustomWidget(widgetId, widgetData.type);
                });
            }
            
            // Restore widget states after refresh
            restoreWidgetStates();
        }

        function toggleBookingWidgetMode(widgetId) {
            const widget = document.getElementById(widgetId);
            const tableContainer = document.getElementById(`table-${widgetId}`);
            
            if (!widget || !tableContainer) return;
            
            const currentMode = tableContainer.dataset.mode || 'large';
            const newMode = currentMode === 'large' ? 'small' : 'large';
            
            // Update widget size classes
            if (newMode === 'large') {
                widget.classList.remove('widget-medium');
                widget.classList.add('widget-full');
            } else {
                widget.classList.remove('widget-full');
                widget.classList.add('widget-medium');
            }
            
            // Re-render the table with new mode
            createUnifiedBookingTable(tableContainer, widgetId, newMode);
            updateBookingListFilterStatus(widgetId);
            
            // Save the size state to localStorage
            saveBookingWidgetState(widgetId, newMode);
            
            // Save to layout customizations for persistence across layout switches
            if (currentView === 'custom' && currentCustomLayout) {
                saveCurrentCustomLayout();
            }
            
            // Show toast notification
            const modeText = newMode === 'large' ? 'expanded' : 'collapsed';
            showToast(`Booking widget ${modeText}`, 'success');
        }

        // Save booking widget state to localStorage
        function saveBookingWidgetState(widgetId, mode) {
            const bookingWidgetStates = JSON.parse(localStorage.getItem('bookingWidgetStates') || '{}');
            bookingWidgetStates[widgetId] = mode;
            localStorage.setItem('bookingWidgetStates', JSON.stringify(bookingWidgetStates));
        }

        // Load booking widget state from localStorage
        function loadBookingWidgetState(widgetId) {
            const bookingWidgetStates = JSON.parse(localStorage.getItem('bookingWidgetStates') || '{}');
            return bookingWidgetStates[widgetId] || 'large'; // Default to large mode
        }

        // Auto-add Add Widget widget after first widget is added
        function autoAddWidgetWidget() {
            const grid = document.getElementById('dashboardGrid');
            const existingWidgets = grid.querySelectorAll('.widget');
            
            // Check if there's already an Add Widget widget
            const hasAddWidget = Array.from(existingWidgets).some(widget => 
                widget.querySelector('.add-widget-widget')
            );
            
            // Only add if there's at least one other widget and no existing Add Widget widget
            if (existingWidgets.length > 0 && !hasAddWidget) {
                const addWidgetId = `add-widget-${Date.now()}`;
                const addWidgetHTML = `
                    <div class="widget widget-medium" id="${addWidgetId}">
                        <div class="add-widget-widget" onclick="openModal('addWidgetModal')" title="Add Widget">
                            <span class="add-widget-icon">➕</span>
                        </div>
                    </div>
                `;
                
                // Always append to the end of the grid
                grid.insertAdjacentHTML('beforeend', addWidgetHTML);
                
                // Initialize draggable widgets
                initializeDraggableWidgets();
                
                // Save the layout
                saveCurrentCustomLayout();
                triggerAutoSave();
                
                // Update mobile UI
                updateMobileUI();
                
                console.log('Auto-added Add Widget widget at the end');
            }
        }
        
        // Ensure Add Widget placeholder is always present in custom layouts
        function ensureAddWidgetPlaceholder() {
            // Only show in custom layouts, not in full view or default view
            if (currentView !== 'custom' || !currentCustomLayout) {
                return;
            }
            
            const grid = document.getElementById('dashboardGrid');
            if (!grid) return;
            
            // Check if there's already an Add Widget widget
            const existingAddWidget = grid.querySelector('.add-widget-widget');
            if (existingAddWidget) {
                console.log('Add Widget placeholder already exists');
                return;
            }
            
            // Create the Add Widget placeholder
            const addWidgetId = `add-widget-${Date.now()}`;
            const addWidgetHTML = `
                <div class="widget widget-medium" id="${addWidgetId}">
                    <div class="add-widget-widget" onclick="openModal('addWidgetModal')" title="Add Widget">
                        <span class="add-widget-icon">➕</span>
                    </div>
                </div>
            `;
            
            // Always append to the end of the grid
            grid.insertAdjacentHTML('beforeend', addWidgetHTML);
            
            // Initialize draggable widgets to include the new placeholder
            initializeDraggableWidgets();
            
            // Update mobile UI
            updateMobileUI();
            
            console.log('Add Widget placeholder re-injected for layout:', currentCustomLayout);
        }

        // Enhanced Layout Management with multiple storage options
        function saveLayout() {
            const layout = createCurrentLayout();
            
            // Migrate layout if needed
            const migratedLayout = migrateLayout(layout);
            
            // Save to multiple storage locations (no file download)
            saveToLocalStorage(migratedLayout);
            saveToIndexedDB(migratedLayout);
            
            showToast('Layout saved to browser cache!', 'success');
        }

        function getCurrentFilters() {
            return {
                timePeriod: document.getElementById('timePeriodFilter').value,
                status: document.getElementById('statusFilter').value
            };
        }

        function getKPISettings() {
            const kpiCards = document.querySelectorAll('.kpi-card');
            return Array.from(kpiCards).map(card => ({
                title: card.querySelector('.kpi-title').textContent,
                visible: !card.style.display || card.style.display !== 'none'
            }));
        }

        function getWidgetSize(widget) {
            const classes = widget.className.split(' ');
            const sizeClass = classes.find(cls => cls.startsWith('widget-'));
            return sizeClass ? sizeClass.replace('widget-', '') : 'medium';
        }

        function getWidgetCustomizations(widget) {
            const customizations = {
                backgroundColor: getComputedStyle(widget).backgroundColor,
                borderColor: getComputedStyle(widget).borderColor,
                customCSS: widget.getAttribute('data-custom-css') || ''
            };
            
            // Save booking widget mode if it's a bookings widget
            if (widget.id.includes('bookings')) {
                const tableContainer = document.getElementById(`table-${widget.id}`);
                if (tableContainer && tableContainer.dataset.mode) {
                    customizations.bookingMode = tableContainer.dataset.mode;
                }
            }
            
            // Save expand state for revenue widgets
            if (widget.id.includes('revenue') || widget.classList.contains('widget-full')) {
                customizations.expanded = widget.classList.contains('widget-full');
            }
            
            return customizations;
        }

        // Enhanced localStorage with compression and error handling
        function saveToLocalStorage(layout) {
            try {
                const compressedLayout = JSON.stringify(layout);
                console.log('Saving to localStorage:', compressedLayout);
                
                // Check if data is too large for localStorage
                if (compressedLayout.length > 5 * 1024 * 1024) { // 5MB limit
                    console.warn('Layout too large for localStorage, using IndexedDB only');
                    return false;
                }
                
                localStorage.setItem('dashboardLayout', compressedLayout);
                localStorage.setItem('dashboardLayoutBackup', compressedLayout);
                localStorage.setItem('lastSaved', new Date().toISOString());
                
                console.log('Successfully saved to localStorage');
                console.log('Verification - dashboardLayout exists:', localStorage.getItem('dashboardLayout') !== null);
                return true;
            } catch (error) {
                console.error('Error saving to localStorage:', error);
                showToast('Could not save to browser cache (localStorage full)', 'warning');
                return false;
            }
        }

        // IndexedDB for larger data storage
        function saveToIndexedDB(layout) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('VenusDashboard', 1);
                
                request.onerror = () => {
                    console.error('IndexedDB error:', request.error);
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    const db = request.result;
                    const transaction = db.transaction(['layouts'], 'readwrite');
                    const store = transaction.objectStore('layouts');
                    
                    const saveRequest = store.put({
                        id: 'current',
                        layout: layout,
                        timestamp: new Date().toISOString(),
                        version: layout.version
                    });
                    
                    saveRequest.onsuccess = () => {
                        console.log('Layout saved to IndexedDB');
                        resolve(true);
                    };
                    
                    saveRequest.onerror = () => {
                        console.error('Error saving to IndexedDB:', saveRequest.error);
                        reject(saveRequest.error);
                    };
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('layouts')) {
                        const store = db.createObjectStore('layouts', { keyPath: 'id' });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                        store.createIndex('version', 'version', { unique: false });
                    }
                };
            });
        }

        function getWidgetType(widget) {
            // Check widget ID first for more reliable identification
            if (widget.id === 'widget-all-bookings' || widget.id === 'widget-bookings') {
                console.log('Mapping All Bookings to Bookings widget type');
                return 'bookings';
            }
            if (widget.id === 'widget-timeline') return 'timeline';
            if (widget.id === 'widget-revenue') return 'revenue-chart';
            if (widget.id === 'widget-services') return 'service-distribution';
            if (widget.id === 'widget-stats') return 'stats';
            if (widget.id.includes('booking-list')) return 'booking-list';
            if (widget.id.includes('calendar')) return 'calendar';
            
            // Fallback to title-based detection
            const title = widget.querySelector('.widget-title');
            if (title) {
                const titleText = title.textContent.toLowerCase();
                if (titleText.includes('revenue')) return 'revenue-chart';
                if (titleText.includes('service')) return 'service-distribution';
                if (titleText.includes('booking calendar')) return 'calendar';
                if (titleText.includes('all bookings') || titleText.includes('bookings')) {
                    console.log('Mapping All Bookings/Bookings title to Bookings widget type');
                    return 'bookings';
                }
                if (titleText.includes('booking') && !titleText.includes('calendar')) return 'booking-list';
                if (titleText.includes('calendar')) return 'calendar';
                if (titleText.includes('stats')) return 'stats';
                if (titleText.includes('timeline')) return 'timeline';
            }
            return 'unknown';
        }

        function getWidgetPosition(widget) {
            const grid = document.getElementById('dashboardGrid');
            const widgets = Array.from(grid.querySelectorAll('.widget'));
            const index = widgets.indexOf(widget);
            return index;
        }

        function downloadLayoutFile(layout) {
            const layoutData = {
                ...layout,
                exportInfo: {
                    exportedAt: new Date().toISOString(),
                    dashboardVersion: 'V0.9beta',
                    projectName: 'Venus DASH',
                    description: 'Custom dashboard layout export'
                }
            };
            
            const dataStr = JSON.stringify(layoutData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `venus-dashboard-layout-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showToast('Layout file downloaded to PC!', 'success');
        }

        // Automatic layout loading on startup
        async function loadLayoutAutomatically() {
            console.log('=== LOADING LAYOUT ON STARTUP ===');
            let layout = null;
            
            // Check what's in localStorage
            console.log('localStorage keys:', Object.keys(localStorage));
            console.log('dashboardLayout exists:', localStorage.getItem('dashboardLayout') !== null);
            console.log('dashboardLayoutBackup exists:', localStorage.getItem('dashboardLayoutBackup') !== null);
            
            // Try to load from localStorage first
            try {
                const savedLayout = localStorage.getItem('dashboardLayout');
                if (savedLayout) {
                    layout = JSON.parse(savedLayout);
                    console.log('Auto-loaded layout from localStorage:', layout);
                } else {
                    console.log('No dashboardLayout found in localStorage');
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
            
            // If localStorage fails, try IndexedDB
            if (!layout) {
                try {
                    layout = await loadFromIndexedDB();
                    console.log('Auto-loaded layout from IndexedDB:', layout);
                } catch (error) {
                    console.error('Error loading from IndexedDB:', error);
                }
            }
            
            // If both fail, try backup
            if (!layout) {
                try {
                    const backupLayout = localStorage.getItem('dashboardLayoutBackup');
                    if (backupLayout) {
                        layout = JSON.parse(backupLayout);
                        console.log('Auto-loaded layout from backup:', layout);
                    } else {
                        console.log('No backup layout found');
                    }
                } catch (error) {
                    console.error('Error loading from backup:', error);
                }
            }
            
            if (layout) {
                console.log('Applying saved layout:', layout);
                
                // Apply theme first (skip auto-save during restoration)
                if (layout.theme) {
                    console.log('Applying theme:', layout.theme);
                    setTheme(layout.theme, true);
                }
                
                // Apply view mode and custom layout
                if (layout.view) {
                    console.log('Applying view mode:', layout.view);
                    currentView = layout.view;
                    
                    // If it's a custom layout, set the current custom layout ID
                    if (layout.view === 'custom' && layout.customLayoutId) {
                        currentCustomLayout = layout.customLayoutId;
                    }
                }
                
                // Apply filters
                if (layout.filters) {
                    console.log('Applying filters:', layout.filters);
                    document.getElementById('timePeriodFilter').value = layout.filters.timePeriod || '';
                    document.getElementById('statusFilter').value = layout.filters.status || '';
                }
                
                // Store the saved layout for use in renderDashboard
                window.savedLayout = layout;
                
                console.log('Layout automatically restored successfully');
            } else {
                console.log('No saved layout found - using default settings');
                console.log('Current theme:', currentTheme);
                console.log('Current view:', currentView);
            }
        }

        function loadFromIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('VenusDashboard', 1);
                
                request.onerror = () => {
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    const db = request.result;
                    const transaction = db.transaction(['layouts'], 'readonly');
                    const store = transaction.objectStore('layouts');
                    const getRequest = store.get('current');
                    
                    getRequest.onsuccess = () => {
                        if (getRequest.result) {
                            resolve(getRequest.result.layout);
                        } else {
                            reject(new Error('No layout found in IndexedDB'));
                        }
                    };
                    
                    getRequest.onerror = () => {
                        reject(getRequest.error);
                    };
                };
            });
        }

        function applyLayout(layout) {
            // Apply theme
            if (layout.theme) {
                setTheme(layout.theme);
            }
            
            // Apply view mode
            if (layout.view) {
                currentView = layout.view;
                document.querySelectorAll('.view-mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.view === layout.view) {
                        btn.classList.add('active');
                    }
                });
            }
            
            // Apply filters
            if (layout.filters) {
                document.getElementById('timePeriodFilter').value = layout.filters.timePeriod || '';
                document.getElementById('statusFilter').value = layout.filters.status || '';
            }
            
            // Apply widgets for custom view
            if (layout.view === 'custom' && layout.widgets && layout.widgets.length > 0) {
                renderCustomLayout(layout.widgets);
            } else {
                renderDashboard();
            }
        }


        function validateLayout(layout) {
            return layout && 
                   layout.version && 
                   layout.timestamp && 
                   Array.isArray(layout.widgets) &&
                   typeof layout.theme === 'string' &&
                   typeof layout.view === 'string';
        }

        // Layout versioning and migration system
        function migrateLayout(layout) {
            const currentVersion = '2.0';
            const layoutVersion = layout.version || '1.0';
            
            if (layoutVersion === currentVersion) {
                return layout; // No migration needed
            }
            
            console.log(`Migrating layout from version ${layoutVersion} to ${currentVersion}`);
            
            // Migration from v1.0 to v2.0
            if (layoutVersion === '1.0') {
                const migratedLayout = {
                    ...layout,
                    version: '2.0',
                    filters: layout.filters || getCurrentFilters(),
                    kpiSettings: layout.kpiSettings || getKPISettings(),
                    metadata: {
                        ...layout.metadata,
                        migratedFrom: layoutVersion,
                        migratedAt: new Date().toISOString(),
                        userAgent: navigator.userAgent,
                        screenResolution: `${screen.width}x${screen.height}`,
                        savedBy: 'Venus Dashboard V0.9beta'
                    }
                };
                
                // Enhance widget data with new properties
                migratedLayout.widgets = layout.widgets.map(widget => ({
                    ...widget,
                    size: widget.size || getWidgetSizeFromClass(widget.classes),
                    customizations: widget.customizations || getDefaultWidgetCustomizations()
                }));
                
                console.log('Layout migrated successfully');
                return migratedLayout;
            }
            
            return layout;
        }

        function getWidgetSizeFromClass(classes) {
            const classArray = classes.split(' ');
            const sizeClass = classArray.find(cls => cls.startsWith('widget-'));
            return sizeClass ? sizeClass.replace('widget-', '') : 'medium';
        }

        function getDefaultWidgetCustomizations() {
            return {
                backgroundColor: '',
                borderColor: '',
                customCSS: ''
            };
        }

        // Layout history management
        function saveLayoutVersion(layout, versionName = null) {
            const versionId = versionName || `version_${Date.now()}`;
            const versionData = {
                ...layout,
                versionId: versionId,
                savedAt: new Date().toISOString(),
                isVersion: true
            };
            
            // Save to IndexedDB with version ID
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('VenusDashboard', 1);
                
                request.onsuccess = () => {
                    const db = request.result;
                    const transaction = db.transaction(['layouts'], 'readwrite');
                    const store = transaction.objectStore('layouts');
                    
                    const saveRequest = store.put({
                        id: versionId,
                        layout: versionData,
                        timestamp: new Date().toISOString(),
                        version: layout.version,
                        isVersion: true
                    });
                    
                    saveRequest.onsuccess = () => {
                        console.log(`Layout version saved: ${versionId}`);
                        resolve(true);
                    };
                    
                    saveRequest.onerror = () => {
                        reject(saveRequest.error);
                    };
                };
            });
        }

        function getLayoutVersions() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('VenusDashboard', 1);
                
                request.onsuccess = () => {
                    const db = request.result;
                    const transaction = db.transaction(['layouts'], 'readonly');
                    const store = transaction.objectStore('layouts');
                    const index = store.index('timestamp');
                    const getAllRequest = index.getAll();
                    
                    getAllRequest.onsuccess = () => {
                        const versions = getAllRequest.result
                            .filter(item => item.isVersion)
                            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        resolve(versions);
                    };
                    
                    getAllRequest.onerror = () => {
                        reject(getAllRequest.error);
                    };
                };
            });
        }
        function renderCustomLayout(savedWidgets) {
            const grid = document.getElementById('dashboardGrid');
            console.log('Rendering custom layout with widgets:', savedWidgets.map(w => w.type).join(', '), 'for layout:', currentCustomLayout);
            
            if (savedWidgets.length === 0) {
                // Show empty state
                grid.innerHTML = `
                    <div class="custom-empty-state">
                        <div class="custom-empty-content">
                            <div class="custom-empty-icon">🎨</div>
                            <h3 class="custom-empty-title">Custom Dashboard</h3>
                            <p class="custom-empty-description">Start building your custom dashboard by adding widgets below.</p>
                            <button class="btn btn-primary custom-empty-button" onclick="openModal('addWidgetModal')">
                                <span>➕</span> Add Your First Widget
                            </button>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Clear grid
            grid.innerHTML = '';
            
            // Always ensure All Bookings widget is present in custom layouts
            let hasAllBookingsWidget = false;
            
            // Recreate widgets in saved order
            savedWidgets.forEach(widgetData => {
                let widgetHTML = '';
                // Preserve original widget ID to maintain layout isolation
                let widgetId = widgetData.id;
                
                // Validate and fix widget ID if needed
                if (!widgetId || !widgetId.startsWith('widget-')) {
                    const layoutPrefix = currentCustomLayout ? `layout-${currentCustomLayout}-` : '';
                    widgetId = `widget-${layoutPrefix}${widgetData.type}-${Date.now()}`;
                    console.warn('Fixed invalid widget ID:', widgetData.id, '->', widgetId);
                } else {
                    console.log('Preserving widget ID:', widgetId, 'for layout:', currentCustomLayout);
                }
                
                // Check if this is a Bookings widget (including legacy All Bookings)
                if (widgetId === 'widget-all-bookings' || widgetId === 'widget-bookings' || 
                    widgetData.type === 'all-bookings' || widgetData.type === 'bookings') {
                    hasAllBookingsWidget = true;
                }
                
                switch(widgetData.type) {
                    case 'revenue-over-time':
                        // Legacy mapping - convert to new unified Revenue Chart
                        console.warn('Legacy widget type "revenue-over-time" detected. Converting to unified "revenue-chart". Please update your layout.');
                        widgetData.type = 'revenue-chart';
                        // Determine initial size based on saved state for legacy widget
                        let legacyRevenueSizeClass = 'widget-medium';
                        if (widgetData.customizations && widgetData.customizations.expanded) {
                            legacyRevenueSizeClass = 'widget-full';
                        }
                        
                        widgetHTML = `
                            <div class="widget ${legacyRevenueSizeClass}" id="${widgetId}">
                                <div class="widget-header">
                                    <h3 class="widget-title">Revenue Chart</h3>
                                    <div class="widget-actions no-print">
                                        <button class="widget-btn" onclick="removeWidget('${widgetId}')">🗑️</button>
                                        <button class="widget-btn" onclick="refreshWidget('${widgetId}')">🔄</button>
                                        <button class="widget-btn" onclick="expandWidget('${widgetId.replace('widget-', '')}')" title="Toggle expand/collapse">⛶</button>
                                    </div>
                                </div>
                                <div class="chart-container">
                                    <canvas id="chart-${widgetId}"></canvas>
                                </div>
                                <div class="resize-handle"></div>
                            </div>
                        `;
                        break;
                        // Fall through to revenue-chart case
                    case 'revenue-chart':
                        // Determine initial size based on saved state
                        let revenueSizeClass = 'widget-medium';
                        if (widgetData.customizations && widgetData.customizations.expanded) {
                            revenueSizeClass = 'widget-full';
                        }
                        
                        widgetHTML = `
                            <div class="widget ${revenueSizeClass}" id="${widgetId}">
                                <div class="widget-header">
                                    <h3 class="widget-title">Revenue Chart</h3>
                                    <div class="widget-actions no-print">
                                        <button class="widget-btn" onclick="removeWidget('${widgetId}')">🗑️</button>
                                        <button class="widget-btn" onclick="refreshWidget('${widgetId}')">🔄</button>
                                        <button class="widget-btn" onclick="expandWidget('${widgetId.replace('widget-', '')}')" title="Toggle expand/collapse">⛶</button>
                                    </div>
                                </div>
                                <div class="booking-list-filter-status" id="filter-status-${widgetId}">
                                    <!-- Filter status will be displayed here -->
                                </div>
                                <div class="chart-container">
                                    <canvas id="chart-${widgetId}"></canvas>
                                </div>
                                <div class="resize-handle"></div>
                            </div>
                        `;
                        break;
                    case 'all-bookings':
                        // Legacy All Bookings - map to unified Bookings widget
                        console.log('Converting legacy All Bookings to unified Bookings widget');
                        let legacyMode = 'large';
                        if (widgetData.customizations && widgetData.customizations.bookingMode) {
                            legacyMode = widgetData.customizations.bookingMode;
                        } else {
                            // Fallback to localStorage state
                            legacyMode = loadBookingWidgetState(widgetId);
                        }
                        const legacySizeClass = legacyMode === 'large' ? 'widget-full' : 'widget-medium';
                        
                        widgetHTML = `
                            <div class="widget ${legacySizeClass}" id="${widgetId}">
                                <div class="widget-header">
                                    <h3 class="widget-title">Bookings</h3>
                                    <div class="widget-actions no-print">
                                        <button class="widget-btn" onclick="toggleBookingWidgetMode('${widgetId}')" title="Toggle view mode">⛶</button>
                                        <button class="widget-btn" onclick="removeWidget('${widgetId}')">🗑️</button>
                                        <button class="widget-btn" onclick="refreshWidget('${widgetId}')">🔄</button>
                                    </div>
                                </div>
                                <div class="booking-list-filter-status" id="booking-list-filter-status-${widgetId}">
                                    <!-- Filter status will be displayed here -->
                                </div>
                                <div id="table-${widgetId}"></div>
                            </div>
                        `;
                        break;
                    case 'service-distribution':
                        widgetHTML = `
                            <div class="widget widget-medium" id="${widgetId}">
                                <div class="widget-header">
                                    <h3 class="widget-title">Service Distribution</h3>
                                    <div class="widget-actions no-print">
                                        <button class="widget-btn" onclick="removeWidget('${widgetId}')">🗑️</button>
                                        <button class="widget-btn" onclick="refreshWidget('${widgetId}')">🔄</button>
                                    </div>
                                </div>
                                <div class="booking-list-filter-status" id="filter-status-${widgetId}">
                                    <!-- Filter status will be displayed here -->
                                </div>
                                <div class="chart-container">
                                    <canvas id="chart-${widgetId}"></canvas>
                                </div>
                                <div class="resize-handle"></div>
                            </div>
                        `;
                        break;
                    case 'add-widget':
                        widgetHTML = `
                            <div class="widget widget-medium" id="${widgetId}">
                                <div class="add-widget-widget" onclick="openModal('addWidgetModal')" title="Add Widget">
                                    <span class="add-widget-icon">➕</span>
                                </div>
                            </div>
                        `;
                        break;
                    case 'bookings':
                        // Determine initial size based on saved state
                        // First check if we have customizations with booking mode
                        let initialMode = 'large';
                        if (widgetData.customizations && widgetData.customizations.bookingMode) {
                            initialMode = widgetData.customizations.bookingMode;
                        } else {
                            // Fallback to localStorage state
                            initialMode = loadBookingWidgetState(widgetId);
                        }
                        const initialSizeClass = initialMode === 'large' ? 'widget-full' : 'widget-medium';
                        
                        widgetHTML = `
                            <div class="widget ${initialSizeClass}" id="${widgetId}">
                                <div class="widget-header">
                                    <h3 class="widget-title">Bookings</h3>
                                    <div class="widget-actions no-print">
                                        <button class="widget-btn" onclick="toggleBookingWidgetMode('${widgetId}')" title="Toggle view mode">⛶</button>
                                        <button class="widget-btn" onclick="removeWidget('${widgetId}')">🗑️</button>
                                        <button class="widget-btn" onclick="refreshWidget('${widgetId}')">🔄</button>
                                    </div>
                                </div>
                                <div class="booking-list-filter-status" id="booking-list-filter-status-${widgetId}">
                                    <!-- Filter status will be displayed here -->
                                </div>
                                <div id="table-${widgetId}"></div>
                            </div>
                        `;
                        break;
                    case 'calendar':
                        widgetHTML = `
                            <div class="widget widget-full" id="${widgetId}">
                                <div class="widget-header">
                                    <h3 class="widget-title">Booking Calendar</h3>
                                    <div class="widget-actions no-print">
                                        <button class="widget-btn" onclick="removeWidget('${widgetId}')">🗑️</button>
                                        <button class="widget-btn" onclick="refreshWidget('${widgetId}')">🔄</button>
                                    </div>
                                </div>
                                <div class="calendar-container" id="calendar-${widgetId}">
                                    <div class="calendar-header">
                                        <div class="calendar-nav">
                                            <button class="btn btn-secondary calendar-nav-btn" onclick="changeCalendarView('${widgetId}', 'prev')">‹</button>
                                            <h4 class="calendar-title" id="calendar-title-${widgetId}">October 2024</h4>
                                            <button class="btn btn-secondary calendar-nav-btn" onclick="changeCalendarView('${widgetId}', 'next')">›</button>
                                        </div>
                                        <div class="calendar-view-toggle">
                                            <button class="btn btn-sm btn-secondary calendar-view-btn active" data-view="month" onclick="switchCalendarView('${widgetId}', 'month')">Month</button>
                                            <button class="btn btn-sm btn-secondary calendar-view-btn" data-view="week" onclick="switchCalendarView('${widgetId}', 'week')">Week</button>
                                            <button class="btn btn-sm btn-secondary calendar-view-btn" data-view="day" onclick="switchCalendarView('${widgetId}', 'day')">Day</button>
                                        </div>
                                    </div>
                                    <div class="calendar-filter-status" id="calendar-filter-status-${widgetId}">
                                        <!-- Filter status will be displayed here -->
                                    </div>
                                    <div class="calendar-content" id="calendar-content-${widgetId}">
                                        <!-- Calendar will be rendered here -->
                                    </div>
                                    <div class="calendar-legend">
                                        <div class="legend-item">
                                            <span class="legend-color pending"></span>
                                            <span>Pending</span>
                                        </div>
                                        <div class="legend-item">
                                            <span class="legend-color confirmed"></span>
                                            <span>Confirmed</span>
                                        </div>
                                        <div class="legend-item">
                                            <span class="legend-color cancelled"></span>
                                            <span>Cancelled</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="resize-handle"></div>
                            </div>
                        `;
                        break;
                    case 'stats':
                        widgetHTML = `
                            <div class="widget widget-medium" id="${widgetId}">
                                <div class="widget-header">
                                    <h3 class="widget-title">Quick Stats</h3>
                                    <div class="widget-actions no-print">
                                        <button class="widget-btn" onclick="removeWidget('${widgetId}')">🗑️</button>
                                        <button class="widget-btn" onclick="refreshWidget('${widgetId}')">🔄</button>
                                    </div>
                                </div>
                                <div class="stats-grid" id="stats-${widgetId}"></div>
                            </div>
                        `;
                        break;
                    case 'timeline':
                        widgetHTML = `
                            <div class="widget widget-medium" id="${widgetId}">
                                <div class="widget-header">
                                    <h3 class="widget-title">Daily Bookings Timeline</h3>
                                    <div class="widget-actions no-print">
                                        <button class="widget-btn" onclick="removeWidget('${widgetId}')">🗑️</button>
                                        <button class="widget-btn" onclick="refreshWidget('${widgetId}')">🔄</button>
                                    </div>
                                </div>
                                <div class="chart-container">
                                    <canvas id="chart-${widgetId}"></canvas>
                                </div>
                                <div class="resize-handle"></div>
                            </div>
                        `;
                        break;
                }
                
                if (widgetHTML) {
                    grid.insertAdjacentHTML('beforeend', widgetHTML);
                }
            });
            
            // Layout isolation: Only render widgets defined in the layout JSON
            // No automatic widget insertion - users must explicitly add widgets via Add Widget
            
            // Initialize all widgets with robust DOM readiness check
            const widgetPromises = savedWidgets.map(widgetData => {
                const widgetId = widgetData.id;
                const selector = widgetData.type === 'stats' ? `#stats-${widgetId}` : `#chart-${widgetId}`;
                return waitForElement(selector, 500).catch(() => null);
            });
            
            Promise.all(widgetPromises).then(() => {
                savedWidgets.forEach(widgetData => {
                    const widgetId = widgetData.id;
                    initializeCustomWidget(widgetId, widgetData.type);
                });
                
                // Initialize any Bookings widgets that are explicitly defined in the layout
                savedWidgets.forEach(widgetData => {
                    if (widgetData.type === 'bookings' || widgetData.type === 'all-bookings') {
                        const widgetId = widgetData.id;
                        const tableContainer = document.getElementById(`table-${widgetId}`);
                        if (tableContainer) {
                            const savedMode = loadBookingWidgetState(widgetId);
                            createUnifiedBookingTable(tableContainer, widgetId, savedMode);
                            updateBookingListFilterStatus(widgetId);
                            console.log('Initialized Bookings widget:', widgetId, 'from layout definition');
                        }
                    }
                });
                
                initializeDraggableWidgets();
                
                // Apply Restricted Mode if active
                if (restrictedMode) {
                    enableRestrictedMode();
                }
                
                // Restore widget states (expanded/collapsed)
                restoreWidgetStates();
                
                // Ensure Add Widget placeholder is always present in custom layouts
                ensureAddWidgetPlaceholder();
            }).catch(() => {
                // Fallback to setTimeout if Promise approach fails
                setTimeout(() => {
                    savedWidgets.forEach(widgetData => {
                        const widgetId = widgetData.id;
                        initializeCustomWidget(widgetId, widgetData.type);
                    });
                    
                    // Initialize any Bookings widgets that are explicitly defined in the layout
                    savedWidgets.forEach(widgetData => {
                        if (widgetData.type === 'bookings' || widgetData.type === 'all-bookings') {
                            const widgetId = widgetData.id;
                            const tableContainer = document.getElementById(`table-${widgetId}`);
                            if (tableContainer) {
                                const savedMode = loadBookingWidgetState(widgetId);
                                createUnifiedBookingTable(tableContainer, widgetId, savedMode);
                                updateBookingListFilterStatus(widgetId);
                                console.log('Initialized Bookings widget:', widgetId, 'from layout definition (fallback)');
                            }
                        }
                    });
                    
                    initializeDraggableWidgets();
                    
                    // Apply Restricted Mode if active
                    if (restrictedMode) {
                        enableRestrictedMode();
                    }
                    
                    // Restore widget states (expanded/collapsed)
                    restoreWidgetStates();
                    
                    // Ensure Add Widget placeholder is always present in custom layouts
                    ensureAddWidgetPlaceholder();
                }, 300);
            });
        }

        // Initialize draggable widgets when dashboard renders
        function initializeDraggableWidgets() {
            setTimeout(() => {
                makeWidgetsDraggable();
            }, 100);
        }

        // Toast Notifications
        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            
            const colors = {
                success: 'var(--accent-secondary)',
                error: 'var(--accent-danger)',
                warning: 'var(--accent-warning)',
                info: 'var(--accent-primary)'
            };
            
            toast.style.borderLeftColor = colors[type] || colors.info;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // iOS-style drag-and-drop implementation with auto-scroll
        let draggedElement = null;
        let draggedOverElement = null;
        let dragStartPosition = null;
        let isDragging = false;
        let autoScrollInterval = null;
        let scrollSpeed = 0;

        // Add draggable attribute to widget headers
        function makeWidgetsDraggable() {
            // Enable mobile detection - disable drag-and-drop on mobile/touch devices
            const isMobile = window.innerWidth <= 768 && ('ontouchstart' in window || navigator.maxTouchPoints > 0);
            
            console.log('makeWidgetsDraggable called:', {
                windowWidth: window.innerWidth,
                hasTouchStart: 'ontouchstart' in window,
                maxTouchPoints: navigator.maxTouchPoints,
                isMobile: isMobile
            });
            
            // First, remove all existing drag event listeners to prevent duplicates
            document.querySelectorAll('.widget-header').forEach(header => {
                header.removeEventListener('dragstart', handleDragStart);
                header.removeEventListener('dragend', handleDragEnd);
            });
            
            if (isMobile) {
                // On mobile, disable drag-and-drop
                console.log('Mobile detected - disabling drag-and-drop');
                document.querySelectorAll('.widget-header').forEach(header => {
                    header.setAttribute('draggable', 'false');
                    header.style.cursor = 'default';
                });
                return;
            }
            
            // Desktop: enable drag-and-drop (like old.html)
            console.log('Desktop detected - enabling drag-and-drop');
            document.querySelectorAll('.widget-header').forEach(header => {
                header.setAttribute('draggable', 'true');
                header.style.cursor = 'move';
                header.addEventListener('dragstart', handleDragStart);
                header.addEventListener('dragend', handleDragEnd);
            });
        }

        function handleDragStart(e) {
            draggedElement = e.target.closest('.widget');
            draggedElement.classList.add('dragging');
            isDragging = true;
            
            // Store original position for smooth animation
            dragStartPosition = {
                x: draggedElement.offsetLeft,
                y: draggedElement.offsetTop
            };
            
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', draggedElement.outerHTML);
            
            // Add subtle animation to other widgets
            document.querySelectorAll('.widget').forEach(widget => {
                if (widget !== draggedElement) {
                    widget.classList.add('drag-placeholder');
                }
            });
            
            // Start auto-scroll detection
            startAutoScrollDetection();
        }

        function handleDragEnd(e) {
            if (draggedElement) {
                draggedElement.classList.remove('dragging');
                draggedElement = null;
                isDragging = false;
            }
            
            // Stop auto-scrolling
            stopAutoScroll();
            
            // Remove all visual effects
            document.querySelectorAll('.widget').forEach(widget => {
                widget.classList.remove('drag-over', 'drag-placeholder', 'drag-insert-before', 'drag-insert-after');
            });
        }

        function startAutoScrollDetection() {
            document.addEventListener('dragover', handleDragOverWithScroll);
        }

        function stopAutoScroll() {
            if (autoScrollInterval) {
                clearInterval(autoScrollInterval);
                autoScrollInterval = null;
            }
            scrollSpeed = 0;
        }

        function handleDragOverWithScroll(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const widget = e.target.closest('.widget');
            const grid = document.getElementById('dashboardGrid');
            
            if (isDragging) {
                // Remove previous highlights
                document.querySelectorAll('.widget').forEach(w => {
                    w.classList.remove('drag-over', 'drag-insert-before', 'drag-insert-after');
                });
                
                if (widget && widget !== draggedElement) {
                    // Highlight widget being dragged over
                    widget.classList.add('drag-over');
                    draggedOverElement = widget;
                } else {
                    // Show insertion point for empty space
                    const dropPosition = getDropPosition(e, grid);
                    if (dropPosition) {
                        if (dropPosition.insertBefore) {
                            dropPosition.insertBefore.classList.add('drag-insert-before');
                        } else if (dropPosition.insertAfter) {
                            dropPosition.insertAfter.classList.add('drag-insert-after');
                        }
                    }
                }
            }
            
            // Auto-scroll detection
            const scrollThreshold = 80; // Distance from edge to trigger scroll (reduced for faster activation)
            const maxScrollSpeed = 25; // Maximum scroll speed (increased for faster scrolling)
            const viewportHeight = window.innerHeight;
            const scrollY = window.scrollY;
            const documentHeight = document.documentElement.scrollHeight;
            
            // Get mouse position relative to viewport
            const mouseY = e.clientY;
            
            // Calculate scroll speed based on distance from edge
            let newScrollSpeed = 0;
            
            if (mouseY < scrollThreshold) {
                // Near top edge - scroll up
                newScrollSpeed = -Math.max(1, (scrollThreshold - mouseY) / scrollThreshold * maxScrollSpeed);
            } else if (mouseY > viewportHeight - scrollThreshold) {
                // Near bottom edge - scroll down
                newScrollSpeed = Math.max(1, (mouseY - (viewportHeight - scrollThreshold)) / scrollThreshold * maxScrollSpeed);
            }
            
            // Update scroll speed
            if (newScrollSpeed !== scrollSpeed) {
                scrollSpeed = newScrollSpeed;
                
                // Clear existing interval
                if (autoScrollInterval) {
                    clearInterval(autoScrollInterval);
                }
                
                // Start new scroll interval if needed
                if (scrollSpeed !== 0) {
                    autoScrollInterval = setInterval(() => {
                        const currentScrollY = window.scrollY;
                        const newScrollY = currentScrollY + scrollSpeed;
                        
                        // Check bounds
                        if (newScrollY >= 0 && newScrollY <= documentHeight - viewportHeight) {
                            window.scrollTo({
                                top: newScrollY,
                                behavior: 'auto' // Use 'auto' for smooth scrolling during drag
                            });
                        } else {
                            // Stop scrolling if we've reached the bounds
                            stopAutoScroll();
                        }
                    }, 16); // ~60fps
                }
            }
        }

        document.addEventListener('dragleave', (e) => {
            const widget = e.target.closest('.widget');
            if (widget && !widget.contains(e.relatedTarget)) {
                widget.classList.remove('drag-over');
            }
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            
            // Stop auto-scrolling immediately on drop
            stopAutoScroll();
            
            const grid = document.getElementById('dashboardGrid');
            const dropTarget = e.target.closest('.widget');
            const dropPosition = getDropPosition(e, grid);
            
            if (isDragging && draggedElement) {
                if (dropTarget && dropTarget !== draggedElement) {
                    // Drop on another widget
                    const widgets = Array.from(grid.querySelectorAll('.widget'));
                    const draggedIndex = widgets.indexOf(draggedElement);
                    const targetIndex = widgets.indexOf(dropTarget);
                    
                    if (draggedIndex !== -1 && targetIndex !== -1) {
                        animateWidgetMove(draggedElement, dropTarget, draggedIndex, targetIndex);
                    }
                } else if (dropPosition) {
                    // Drop in empty space
                    animateWidgetMoveToPosition(draggedElement, dropPosition);
                }
            }
            
            // Clean up
            document.querySelectorAll('.widget').forEach(widget => {
                widget.classList.remove('drag-over', 'drag-placeholder', 'drag-insert-before', 'drag-insert-after');
            });
        });

        function getDropPosition(e, grid) {
            const gridRect = grid.getBoundingClientRect();
            const mouseX = e.clientX;
            const mouseY = e.clientY;
            
            // Check if mouse is within grid bounds
            if (mouseX < gridRect.left || mouseX > gridRect.right || 
                mouseY < gridRect.top || mouseY > gridRect.bottom) {
                return null;
            }
            
            // Get all widgets and their positions
            const widgets = Array.from(grid.querySelectorAll('.widget'));
            const widgetPositions = widgets.map(widget => {
                const rect = widget.getBoundingClientRect();
                return {
                    element: widget,
                    top: rect.top,
                    bottom: rect.bottom,
                    left: rect.left,
                    right: rect.right,
                    centerY: rect.top + rect.height / 2
                };
            });
            
            // Find the best insertion point based on mouse position
            let insertIndex = widgets.length; // Default to end
            
            for (let i = 0; i < widgetPositions.length; i++) {
                const widget = widgetPositions[i];
                
                // Check if mouse is above this widget's center
                if (mouseY < widget.centerY) {
                    insertIndex = i;
                    break;
                }
            }
            
            return {
                index: insertIndex,
                insertAfter: insertIndex > 0 ? widgets[insertIndex - 1] : null,
                insertBefore: insertIndex < widgets.length ? widgets[insertIndex] : null
            };
        }

        function animateWidgetMoveToPosition(draggedWidget, position) {
            const grid = document.getElementById('dashboardGrid');
            
            // If the dragged widget is an Add Widget widget, always place it at the end
            if (draggedWidget.querySelector('.add-widget-widget')) {
                // Temporarily disable transitions for instant positioning
                const allWidgets = document.querySelectorAll('.widget');
                allWidgets.forEach(widget => {
                    widget.style.transition = 'none';
                });
                
                // Remove dragged element temporarily
                draggedWidget.style.opacity = '0';
                
                // Always append to the end
                grid.appendChild(draggedWidget);
                
                // Re-enable transitions and animate
                setTimeout(() => {
                    allWidgets.forEach(widget => {
                        widget.style.transition = '';
                    });
                    draggedWidget.style.opacity = '';
                    draggedWidget.classList.remove('dragging');
                    
                    showToast('Add Widget widget repositioned to end!', 'success');
                    triggerAutoSave(); // Auto-save when widget is repositioned
                }, 50);
                return;
            }
            
            // Regular widget positioning logic for non-Add Widget widgets
            // Temporarily disable transitions for instant positioning
            const allWidgets = document.querySelectorAll('.widget');
            allWidgets.forEach(widget => {
                widget.style.transition = 'none';
            });
            
            // Remove dragged element temporarily
            draggedWidget.style.opacity = '0';
            
            // Insert at calculated position
            if (position.insertAfter) {
                position.insertAfter.insertAdjacentElement('afterend', draggedWidget);
            } else if (position.insertBefore) {
                position.insertBefore.insertAdjacentElement('beforebegin', draggedWidget);
            } else {
                // Insert at end
                grid.appendChild(draggedWidget);
            }
            
            // Re-enable transitions and animate
            setTimeout(() => {
                allWidgets.forEach(widget => {
                    widget.style.transition = '';
                });
                draggedWidget.style.opacity = '';
                draggedWidget.classList.remove('dragging');
                
                showToast('Widget repositioned successfully!', 'success');
                triggerAutoSave(); // Auto-save when widget is repositioned
            }, 50);
        }

        function animateWidgetMove(draggedWidget, targetWidget, draggedIndex, targetIndex) {
            // If the dragged widget is an Add Widget widget, always place it at the end
            if (draggedWidget.querySelector('.add-widget-widget')) {
                const grid = document.getElementById('dashboardGrid');
                
                // Temporarily disable transitions for instant positioning
                const allWidgets = document.querySelectorAll('.widget');
                allWidgets.forEach(widget => {
                    widget.style.transition = 'none';
                });
                
                // Remove dragged element temporarily
                draggedWidget.style.opacity = '0';
                
                // Always append to the end
                grid.appendChild(draggedWidget);
                
                // Re-enable transitions and animate
                setTimeout(() => {
                    allWidgets.forEach(widget => {
                        widget.style.transition = '';
                    });
                    draggedWidget.style.opacity = '';
                    draggedWidget.classList.remove('dragging');
                    
                    showToast('Add Widget widget repositioned to end!', 'success');
                    triggerAutoSave(); // Auto-save when widget is moved
                }, 50);
                return;
            }
            
            // Regular widget move logic for non-Add Widget widgets
            // Temporarily disable transitions for instant positioning
            const allWidgets = document.querySelectorAll('.widget');
            allWidgets.forEach(widget => {
                widget.style.transition = 'none';
            });
            
            // Remove dragged element temporarily
            const draggedClone = draggedWidget.cloneNode(true);
            draggedWidget.style.opacity = '0';
            
            // Insert at new position
            if (draggedIndex < targetIndex) {
                targetWidget.insertAdjacentElement('afterend', draggedWidget);
            } else {
                targetWidget.insertAdjacentElement('beforebegin', draggedWidget);
            }
            
            // Re-enable transitions and animate
            setTimeout(() => {
                allWidgets.forEach(widget => {
                    widget.style.transition = '';
                });
                draggedWidget.style.opacity = '';
                draggedWidget.classList.remove('dragging');
                
                showToast('Widget moved successfully!', 'success');
                triggerAutoSave(); // Auto-save when widget is moved
            }, 50);
        }

        // Mobile device detection and UI updates
        function updateMobileUI() {
            // Use the same improved mobile detection logic
            const isMobile = window.innerWidth <= 768 && ('ontouchstart' in window || navigator.maxTouchPoints > 0);
            const mobileAddButton = document.getElementById('mobileAddButton');
            
            if (isMobile) {
                // Show mobile floating button only in custom view when no Add Widget widget exists
                const grid = document.getElementById('dashboardGrid');
                const hasAddWidget = grid.querySelector('.add-widget-widget');
                
                if (mobileAddButton) {
                    mobileAddButton.style.display = (currentView === 'custom' && !hasAddWidget) ? 'flex' : 'none';
                }
            } else {
                // Hide mobile floating button on desktop
                if (mobileAddButton) {
                    mobileAddButton.style.display = 'none';
                }
            }
        }

        // Initialize mobile UI on load and resize
        function initializeMobileUI() {
            updateMobileUI();
            
            // Update on window resize
            window.addEventListener('resize', debounce(() => {
                updateMobileUI();
                // Re-initialize draggable widgets when switching between mobile/desktop
                initializeDraggableWidgets();
            }, 250));
        }

        // Test function to debug drag-and-drop
        function testDragAndDrop() {
            console.log('=== DRAG AND DROP TEST ===');
            const headers = document.querySelectorAll('.widget-header');
            console.log('Found widget headers:', headers.length);
            headers.forEach((header, index) => {
                console.log(`Header ${index}:`, {
                    draggable: header.getAttribute('draggable'),
                    cursor: header.style.cursor,
                    hasDragStart: header.ondragstart !== null
                });
            });
        }

        // Make test function available globally for debugging
        window.testDragAndDrop = testDragAndDrop;

        // Test function to debug saving/loading
        function testSave() {
            console.log('=== TEST SAVE ===');
            console.log('Current theme:', currentTheme);
            
            saveToLocalStorage(layout);
            console.log('Saved to localStorage');
            
            // Check what's actually saved
            const saved = localStorage.getItem('dashboardLayout');
            console.log('Actually saved:', JSON.parse(saved));
            
            showToast('Test save completed - check console', 'info');
        }
        
        // Test function to debug restricted mode functionality
        function testRestrictedMode() {
            console.log('=== TEST RESTRICTED MODE ===');
            console.log('Current restricted mode:', restrictedMode);
            console.log('KPI Grid element:', document.getElementById('kpiGrid'));
            console.log('KPI values:', document.querySelectorAll('.kpi-value'));
            console.log('Restricted widgets:', document.querySelectorAll('.restricted-widget'));
            console.log('Registered listeners:', restrictedModeListeners.length);
            
            // Test toggling restricted mode
            if (restrictedMode) {
                console.log('Testing unlock...');
                restrictedMode = false;
                disableRestrictedMode();
            } else {
                console.log('Testing lock...');
                restrictedMode = true;
                enableRestrictedMode();
            }
            
            showToast('Restricted mode test completed - check console', 'info');
        }
        
        // Test function to debug improvement calculations
        function testImprovements() {
            console.log('=== TEST IMPROVEMENT CALCULATIONS ===');
            console.log('Current filters:', getCurrentFilters());
            console.log('Filtered data bookings:', filteredData?.bookings?.length);
            
            const currentFilters = getCurrentFilters();
            const improvements = calculateImprovements(filteredData, currentFilters);
            console.log('Calculated improvements:', improvements);
            
            // Check for duplicate improvement lines
            const kpiTrends = document.querySelectorAll('.kpi-trend');
            const kpiImprovements = document.querySelectorAll('.kpi-improvement');
            console.log('KPI trend elements:', kpiTrends.length);
            console.log('KPI improvement elements (should be 0):', kpiImprovements.length);
            
            if (kpiImprovements.length > 0) {
                console.warn('⚠️ DUPLICATE IMPROVEMENT LINES DETECTED!');
            } else {
                console.log('✅ No duplicate improvement lines found');
            }
            
            // Test different filter combinations
            const testFilters = [
                { timePeriod: 'thisWeek', status: '' },
                { timePeriod: 'thisMonth', status: 'confirmed' },
                { timePeriod: 'lastMonth', status: 'pending' },
                { timePeriod: 'allTime', status: 'cancelled' }
            ];
            
            testFilters.forEach((filters, index) => {
                console.log(`Test ${index + 1}:`, filters);
                const testImprovements = calculateImprovements(filteredData, filters);
                console.log('Improvements:', testImprovements);
            });
            
            showToast('Improvement test completed - check console', 'info');
        }
        
        // Make test functions available globally for debugging
        window.testRestrictedMode = testRestrictedMode;
        window.testImprovements = testImprovements;

        // Manual save function
        function manualSave() {
            console.log('=== MANUAL SAVE ===');
            console.log('Current theme:', currentTheme);
            console.log('Current view:', currentView);
            console.log('Current filters:', getCurrentFilters());
            
            const layout = createCurrentLayout();
            console.log('Layout to save:', layout);
            
            saveToLocalStorage(layout);
            saveToIndexedDB(layout);
            
            showToast('Layout saved manually!', 'success');
        }

        // Calendar Widget Functions
        let currentCalendarWidget = null;
        let currentCalendarDate = new Date();
        let currentCalendarView = 'month';
        let currentBookingData = null;

        function initializeCalendarWidget(widgetId) {
            currentCalendarWidget = widgetId;
            
            // Reset calendar view to month and update button states
            currentCalendarView = 'month';
            updateCalendarViewButtons(widgetId);
            
            renderCalendar();
        }

        function updateCalendarViewButtons(widgetId) {
            // Update all calendar view buttons to remove active class
            document.querySelectorAll(`#calendar-${widgetId} .calendar-view-btn`).forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Set the correct button as active based on current view
            const activeBtn = document.querySelector(`#calendar-${widgetId} .calendar-view-btn[data-view="${currentCalendarView}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }

        function renderCalendar() {
            if (!currentCalendarWidget) return;
            
            const container = document.getElementById(`calendar-content-${currentCalendarWidget}`);
            const title = document.getElementById(`calendar-title-${currentCalendarWidget}`);
            
            if (!container || !title) return;

            // Update title
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            title.textContent = `${monthNames[currentCalendarDate.getMonth()]} ${currentCalendarDate.getFullYear()}`;

            // Update filter status
            updateCalendarFilterStatus();

            // Get filtered bookings for the current period
            const bookings = getFilteredBookingsForPeriod();
            // Empty state handling
            if (!bookings || bookings.length === 0) {
                // Clear any previous rendered content to avoid confusion, then show overlay
                container.innerHTML = '';
                const currentLabel = getCurrentPeriodLabel(getCurrentFilters());
                ensureEmptyState(container, `No data available for ${currentLabel}.`);
                return;
            } else {
                clearEmptyState(container);
            }
            
            switch(currentCalendarView) {
                case 'month':
                    renderMonthView(container, bookings);
                    break;
                case 'week':
                    renderWeekView(container, bookings);
                    break;
                case 'day':
                    renderDayView(container, bookings);
                    break;
            }
        }

        function updateCalendarFilterStatus() {
            if (!currentCalendarWidget) return;
            
            const filterStatusContainer = document.getElementById(`calendar-filter-status-${currentCalendarWidget}`);
            if (!filterStatusContainer) return;

            updateFilterStatusDisplay(filterStatusContainer);
        }
        function updateBookingListFilterStatus(widgetId) {
            const filterStatusContainer = document.getElementById(`booking-list-filter-status-${widgetId}`);
            if (!filterStatusContainer) return;

            updateFilterStatusDisplay(filterStatusContainer);
        }

        function updateFilterStatusDisplay(container) {
            const timePeriod = document.getElementById('timePeriodFilter')?.value || '';
            const status = document.getElementById('statusFilter')?.value || '';
            
            let statusItems = [];
            let hasFilters = false;

            // Check for time period filters
            if (timePeriod) {
                hasFilters = true;
                const periodNames = {
                    'thisWeek': '📅 This Week',
                    'thisMonth': '📅 This Month',
                    'lastMonth': '📅 Last Month',
                    'jan2025': '📅 Jan 2025',
                    'feb2025': '📅 Feb 2025',
                    'mar2025': '📅 Mar 2025',
                    'apr2025': '📅 Apr 2025',
                    'may2025': '📅 May 2025',
                    'jun2025': '📅 Jun 2025',
                    'jul2025': '📅 Jul 2025',
                    'aug2025': '📅 Aug 2025',
                    'sep2025': '📅 Sep 2025',
                    'oct2025': '📅 Oct 2025',
                    'nov2025': '📅 Nov 2025',
                    'dec2025': '📅 Dec 2025'
                };
                statusItems.push(`<span class="filter-status-item"><span class="filter-status-icon">📅</span> ${periodNames[timePeriod] || timePeriod}</span>`);
            }

            // Check for status filters
            if (status) {
                hasFilters = true;
                const statusNames = {
                    'pending': '⏳ Pending',
                    'confirmed': '✅ Confirmed',
                    'cancelled': '❌ Cancelled'
                };
                statusItems.push(`<span class="filter-status-item"><span class="filter-status-icon">${status === 'pending' ? '⏳' : status === 'confirmed' ? '✅' : '❌'}</span> ${statusNames[status] || status}</span>`);
            }

            // Update the filter status display
            if (hasFilters) {
                container.innerHTML = `<span class="filter-status-icon">🔍</span> Showing: ${statusItems.join(', ')}`;
                container.classList.add('has-filters');
            } else {
                container.innerHTML = '<span class="filter-status-icon">📋</span> Showing all bookings';
                container.classList.remove('has-filters');
            }
        }

        function updateRevenueFilterStatus(widgetId) {
            const filterStatusContainer = document.getElementById(`filter-status-${widgetId}`);
            if (!filterStatusContainer) return;

            const timePeriod = document.getElementById('timePeriodFilter')?.value || '';
            const status = document.getElementById('statusFilter')?.value || '';
            
            let statusItems = [];
            let hasFilters = false;

            // Check for time period filters
            if (timePeriod) {
                hasFilters = true;
                const periodNames = {
                    'thisWeek': '📅 This Week',
                    'thisMonth': '📅 This Month',
                    'lastMonth': '📅 Last Month',
                    'jan2025': '📅 Jan 2025',
                    'feb2025': '📅 Feb 2025',
                    'mar2025': '📅 Mar 2025',
                    'apr2025': '📅 Apr 2025',
                    'may2025': '📅 May 2025',
                    'jun2025': '📅 Jun 2025',
                    'jul2025': '📅 Jul 2025',
                    'aug2025': '📅 Aug 2025',
                    'sep2025': '📅 Sep 2025',
                    'oct2025': '📅 Oct 2025',
                    'nov2025': '📅 Nov 2025',
                    'dec2025': '📅 Dec 2025'
                };
                statusItems.push(`<span class="filter-status-item"><span class="filter-status-icon">📅</span> ${periodNames[timePeriod] || timePeriod}</span>`);
            }

            // Check for status filters
            if (status) {
                hasFilters = true;
                const statusNames = {
                    'pending': '⏳ Pending',
                    'confirmed': '✅ Confirmed',
                    'cancelled': '❌ Cancelled'
                };
                statusItems.push(`<span class="filter-status-item"><span class="filter-status-icon">${status === 'pending' ? '⏳' : status === 'confirmed' ? '✅' : '❌'}</span> ${statusNames[status] || status}</span>`);
            }

            // Update the filter status display
            if (hasFilters) {
                filterStatusContainer.innerHTML = `<span class="filter-status-icon">🔍</span> Showing: ${statusItems.join(', ')}`;
                filterStatusContainer.classList.add('has-filters');
            } else {
                filterStatusContainer.innerHTML = '<span class="filter-status-icon">💰</span> Showing all revenue data';
                filterStatusContainer.classList.remove('has-filters');
            }
        }

        function updateServicesFilterStatus(widgetId) {
            const filterStatusContainer = document.getElementById(`filter-status-${widgetId}`);
            if (!filterStatusContainer) return;

            const timePeriod = document.getElementById('timePeriodFilter')?.value || '';
            const status = document.getElementById('statusFilter')?.value || '';
            
            let statusItems = [];
            let hasFilters = false;

            // Check for time period filters
            if (timePeriod) {
                hasFilters = true;
                const periodNames = {
                    'thisWeek': '📅 This Week',
                    'thisMonth': '📅 This Month',
                    'lastMonth': '📅 Last Month',
                    'jan2025': '📅 Jan 2025',
                    'feb2025': '📅 Feb 2025',
                    'mar2025': '📅 Mar 2025',
                    'apr2025': '📅 Apr 2025',
                    'may2025': '📅 May 2025',
                    'jun2025': '📅 Jun 2025',
                    'jul2025': '📅 Jul 2025',
                    'aug2025': '📅 Aug 2025',
                    'sep2025': '📅 Sep 2025',
                    'oct2025': '📅 Oct 2025',
                    'nov2025': '📅 Nov 2025',
                    'dec2025': '📅 Dec 2025'
                };
                statusItems.push(`<span class="filter-status-item"><span class="filter-status-icon">📅</span> ${periodNames[timePeriod] || timePeriod}</span>`);
            }

            // Check for status filters
            if (status) {
                hasFilters = true;
                const statusNames = {
                    'pending': '⏳ Pending',
                    'confirmed': '✅ Confirmed',
                    'cancelled': '❌ Cancelled'
                };
                statusItems.push(`<span class="filter-status-item"><span class="filter-status-icon">${status === 'pending' ? '⏳' : status === 'confirmed' ? '✅' : '❌'}</span> ${statusNames[status] || status}</span>`);
            }

            // Update the filter status display
            if (hasFilters) {
                filterStatusContainer.innerHTML = `<span class="filter-status-icon">🔍</span> Showing: ${statusItems.join(', ')}`;
                filterStatusContainer.classList.add('has-filters');
            } else {
                filterStatusContainer.innerHTML = '<span class="filter-status-icon">🥧</span> Showing all service data';
                filterStatusContainer.classList.remove('has-filters');
            }
        }

        function refreshAllBookingListWidgets() {
            // Find all booking list widgets and refresh their content and filter status
            document.querySelectorAll('.widget').forEach(widget => {
                if (widget.id.includes('bookings')) {
                    const widgetId = widget.id;
                    const tableContainer = document.getElementById(`table-${widgetId}`);
                    if (tableContainer) {
                        const currentMode = tableContainer.dataset.mode || 'large';
                        createUnifiedBookingTable(tableContainer, widgetId, currentMode);
                        updateBookingListFilterStatus(widgetId);
                    }
                }
            });
            
            // Also refresh the main Bookings widget in full view
            const bookingsWidget = document.querySelector('#widget-bookings, [id*="bookings"]');
            if (bookingsWidget) {
                const tableContainer = document.querySelector('#table-widget-bookings, [id*="table-"][id*="bookings"]');
                if (tableContainer) {
                    const currentMode = tableContainer.dataset.mode || 'large';
                    createUnifiedBookingTable(tableContainer, bookingsWidget.id || 'widget-bookings', currentMode);
                    updateBookingListFilterStatus(bookingsWidget.id || 'widget-bookings');
                }
            }
            
            // Apply Restricted Mode after refresh
            if (restrictedMode) {
                enableRestrictedMode();
            }
        }

        // Toolbar Toggle Functionality
        function toggleToolbar() {
            const toolbar = document.getElementById('toolbar');
            const toggle = document.getElementById('toolbarToggle');
            
            if (toolbar.classList.contains('collapsed')) {
                // Show toolbar
                toolbar.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.innerHTML = '📋';
                toggle.title = 'Hide Filters & Layout';
                localStorage.setItem('toolbarCollapsed', 'false');
            } else {
                // Hide toolbar
                toolbar.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.innerHTML = '⬆️';
                toggle.title = 'Show Filters & Layout';
                localStorage.setItem('toolbarCollapsed', 'true');
            }
        }

        // Initialize toolbar state from localStorage
        function initializeToolbarState() {
            const toolbar = document.getElementById('toolbar');
            const toggle = document.getElementById('toolbarToggle');
            const isCollapsed = localStorage.getItem('toolbarCollapsed') === 'true';
            
            if (isCollapsed) {
                toolbar.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.innerHTML = '⬆️';
                toggle.title = 'Show Filters & Layout';
            } else {
                toolbar.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.innerHTML = '📋';
                toggle.title = 'Hide Filters & Layout';
            }
        }

        function getFilteredBookingsForPeriod() {
            // Use the same filtered data that other widgets use
            if (!filteredData || !filteredData.bookings) return [];
            
            const startDate = new Date(currentCalendarDate);
            const endDate = new Date(currentCalendarDate);
            
            switch(currentCalendarView) {
                case 'month':
                    startDate.setDate(1);
                    endDate.setMonth(endDate.getMonth() + 1);
                    endDate.setDate(0);
                    break;
                case 'week':
                    const dayOfWeek = startDate.getDay();
                    startDate.setDate(startDate.getDate() - dayOfWeek);
                    endDate.setDate(startDate.getDate() + 6);
                    break;
                case 'day':
                    // Same day - no modification needed
                    break;
            }
            
            // Convert dates to YYYY/MM/DD format for comparison
            const formatDate = (date) => {
                return date.getFullYear() + '/' + 
                       String(date.getMonth() + 1).padStart(2, '0') + '/' + 
                       String(date.getDate()).padStart(2, '0');
            };
            
            const startDateStr = formatDate(startDate);
            const endDateStr = formatDate(endDate);
            
            return filteredData.bookings.filter(booking => {
                return booking.date >= startDateStr && booking.date <= endDateStr;
            });
        }

        function renderMonthView(container, bookings) {
            const today = new Date();
            const year = currentCalendarDate.getFullYear();
            const month = currentCalendarDate.getMonth();
            
            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - firstDay.getDay());
            
            // Get all bookings for the extended period (including adjacent months)
            const extendedBookings = getExtendedMonthBookings();
            
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            
            let html = '<div class="calendar-month">';
            
            // Day headers
            days.forEach(day => {
                html += `<div class="calendar-day-header">${day}</div>`;
            });
            
            // Calendar days
            for (let i = 0; i < 42; i++) {
                const currentDate = new Date(startDate);
                currentDate.setDate(startDate.getDate() + i);
                
                const isCurrentMonth = currentDate.getMonth() === month;
                const isToday = currentDate.toDateString() === today.toDateString();
                
                // Format current date to match booking date format (YYYY/MM/DD)
                const currentDateStr = currentDate.getFullYear() + '/' + 
                                     String(currentDate.getMonth() + 1).padStart(2, '0') + '/' + 
                                     String(currentDate.getDate()).padStart(2, '0');
                
                const dayBookings = extendedBookings.filter(booking => {
                    return booking.date === currentDateStr;
                });
                
                let dayClass = 'calendar-day';
                if (!isCurrentMonth) dayClass += ' other-month';
                if (isToday) dayClass += ' today';
                
                html += `<div class="${dayClass}">`;
                html += `<div class="calendar-day-number">${currentDate.getDate()}</div>`;
                
                if (dayBookings.length > 0) {
                    html += '<div class="calendar-bookings">';
                    dayBookings.forEach(booking => {
                        const time = booking.time || '09:00';
                        html += `<div class="calendar-booking ${booking.status}" onclick="showBookingDetails('${booking.id}')" title="${booking.customerName} - ${time}">`;
                        html += `${time} - ${booking.customerName}`;
                        html += '</div>';
                    });
                    html += '</div>';
                }
                
                html += '</div>';
            }
            
            html += '</div>';
            container.innerHTML = html;
        }

        function getExtendedMonthBookings() {
            // Get bookings for the current month plus adjacent months that appear in the calendar grid
            if (!filteredData || !filteredData.bookings) return [];
            
            const year = currentCalendarDate.getFullYear();
            const month = currentCalendarDate.getMonth();
            
            // Calculate the extended date range (6 weeks = 42 days)
            const firstDay = new Date(year, month, 1);
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - firstDay.getDay());
            
            const endDate = new Date(startDate);
            endDate.setDate(startDate.getDate() + 41); // 42 days total (6 weeks)
            
            // Convert to YYYY/MM/DD format
            const formatDate = (date) => {
                return date.getFullYear() + '/' + 
                       String(date.getMonth() + 1).padStart(2, '0') + '/' + 
                       String(date.getDate()).padStart(2, '0');
            };
            
            const startDateStr = formatDate(startDate);
            const endDateStr = formatDate(endDate);
            
            return filteredData.bookings.filter(booking => {
                return booking.date >= startDateStr && booking.date <= endDateStr;
            });
        }

        function renderWeekView(container, bookings) {
            const today = new Date();
            const startOfWeek = new Date(currentCalendarDate);
            const dayOfWeek = startOfWeek.getDay();
            startOfWeek.setDate(startOfWeek.getDate() - dayOfWeek);
            
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const timeSlots = ['09:00', '11:00', '13:00', '15:00'];
            
            let html = '<div class="calendar-week">';
            
            // Time column
            html += '<div class="calendar-time-column">';
            html += '<div class="calendar-time-slot"></div>'; // Empty header
            timeSlots.forEach(time => {
                html += `<div class="calendar-time-slot">${time}</div>`;
            });
            html += '</div>';
            
            // Days
            for (let i = 0; i < 7; i++) {
                const currentDate = new Date(startOfWeek);
                currentDate.setDate(startOfWeek.getDate() + i);
                
                html += '<div class="calendar-week-day">';
                html += `<div class="calendar-week-day-header">${days[i]} ${currentDate.getDate()}</div>`;
                
                timeSlots.forEach(time => {
                    const slotBookings = bookings.filter(booking => {
                        const bookingDate = new Date(booking.date);
                        return bookingDate.toDateString() === currentDate.toDateString() && 
                               booking.time === time;
                    });
                    
                    html += '<div class="calendar-week-slot">';
                    slotBookings.forEach(booking => {
                        html += `<div class="calendar-week-booking ${booking.status}" onclick="showBookingDetails('${booking.id}')" title="${booking.customerName} - ${booking.time}">`;
                        html += `${booking.time} - ${booking.customerName}`;
                        html += '</div>';
                    });
                    html += '</div>';
                });
                
                html += '</div>';
            }
            
            html += '</div>';
            container.innerHTML = html;
        }

        function renderDayView(container, bookings) {
            const today = new Date();
            const timeSlots = ['09:00', '11:00', '13:00', '15:00'];
            
            let html = '<div class="calendar-day-view">';
            html += `<div class="calendar-day-header-view">${currentCalendarDate.toDateString()}</div>`;
            html += '<div class="calendar-day-time-slots">';
            
            timeSlots.forEach(time => {
                const slotBookings = bookings.filter(booking => {
                    // Format current calendar date to match booking date format (YYYY/MM/DD)
                    const currentDateStr = currentCalendarDate.getFullYear() + '/' + 
                                         String(currentCalendarDate.getMonth() + 1).padStart(2, '0') + '/' + 
                                         String(currentCalendarDate.getDate()).padStart(2, '0');
                    return booking.date === currentDateStr && booking.time === time;
                });
                
                html += '<div class="calendar-day-slot">';
                html += `<div class="calendar-day-slot-time">${time}</div>`;
                html += '<div class="calendar-day-slot-bookings">';
                
                if (slotBookings.length > 0) {
                    slotBookings.forEach(booking => {
                        html += `<div class="calendar-day-booking ${booking.status}" onclick="showBookingDetails('${booking.id}')" title="Click to view details">`;
                        html += `<strong>${booking.customerName}</strong><br>`;
                        html += `<small>${booking.carDetails}</small><br>`;
                        html += `<small style="text-transform: capitalize;">Status: ${booking.status}</small>`;
                        html += '</div>';
                    });
                } else {
                    html += '<div style="color: var(--text-secondary); font-style: italic;">No bookings</div>';
                }
                
                html += '</div>';
                html += '</div>';
            });
            
            html += '</div>';
            html += '</div>';
            container.innerHTML = html;
        }

        function changeCalendarView(widgetId, direction) {
            if (direction === 'prev') {
                switch(currentCalendarView) {
                    case 'month':
                        currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
                        break;
                    case 'week':
                        currentCalendarDate.setDate(currentCalendarDate.getDate() - 7);
                        break;
                    case 'day':
                        currentCalendarDate.setDate(currentCalendarDate.getDate() - 1);
                        break;
                }
            } else {
                switch(currentCalendarView) {
                    case 'month':
                        currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
                        break;
                    case 'week':
                        currentCalendarDate.setDate(currentCalendarDate.getDate() + 7);
                        break;
                    case 'day':
                        currentCalendarDate.setDate(currentCalendarDate.getDate() + 1);
                        break;
                }
            }
            renderCalendar();
        }

        function switchCalendarView(widgetId, view) {
            currentCalendarView = view;
            
            // Update active button
            updateCalendarViewButtons(widgetId);
            
            renderCalendar();
        }

        function showBookingDetails(bookingId) {
            const booking = filteredData.bookings.find(b => b.id === bookingId);
            if (!booking) return;
            
            currentBookingData = booking;
            
            // Populate modal
            document.getElementById('booking-customer-name').textContent = booking.customerName;
            const mask = restrictedMode;
            document.getElementById('booking-phone').textContent = mask ? '•••• •••• ••••' : booking.phone;
            document.getElementById('booking-email').textContent = mask ? '••••••••@•••••••' : booking.email;
            document.getElementById('booking-date').textContent = booking.date;
            document.getElementById('booking-time').textContent = booking.time;
            document.getElementById('booking-car').textContent = booking.carDetails;
            document.getElementById('booking-notes').textContent = mask ? 'Hidden while Restricted Mode is active' : (booking.notes || 'No notes');
            
            // Update status badge
            const statusBadge = document.getElementById('booking-status');
            statusBadge.textContent = booking.status;
            statusBadge.className = `status-badge ${booking.status}`;
            
            // Update services
            const servicesContainer = document.getElementById('booking-services');
            servicesContainer.innerHTML = '';
            booking.services.forEach(serviceId => {
                const serviceName = dashboardData.settings.serviceTypes[serviceId]?.name || serviceId;
                const serviceTag = document.createElement('span');
                serviceTag.className = 'service-tag';
                if (restrictedMode && /\$/.test(serviceName)) {
                    serviceTag.textContent = '••••';
                } else {
                serviceTag.textContent = serviceName;
                }
                servicesContainer.appendChild(serviceTag);
            });
            
            // If restricted, display a lock note inside the modal
            const modalBody = document.querySelector('#bookingDetailsModal .modal-body');
            if (modalBody) {
                let note = modalBody.querySelector('.restricted-note');
                if (restrictedMode) {
                    if (!note) {
                        note = document.createElement('div');
                        note.className = 'restricted-note';
                        note.style.marginTop = '0.5rem';
                        note.style.color = 'var(--text-secondary)';
                        note.innerHTML = '🔒 Sensitive details are hidden. Enter the password to view.';
                        modalBody.appendChild(note);
                    }
                } else if (note) {
                    note.remove();
                }
            }
            
            // Show/hide action buttons based on current status
            const cancelBtn = document.getElementById('cancelBookingBtn');
            const pendingBtn = document.getElementById('pendingBookingBtn');
            const confirmBtn = document.getElementById('confirmBookingBtn');
            
            cancelBtn.style.display = booking.status !== 'cancelled' ? 'block' : 'none';
            pendingBtn.style.display = booking.status !== 'pending' ? 'block' : 'none';
            confirmBtn.style.display = booking.status !== 'confirmed' ? 'block' : 'none';
            
            openModal('bookingDetailsModal');
        }

        function updateBookingStatus(newStatus) {
            if (!currentBookingData) return;
            
            // Update the booking in the data
            const bookingIndex = dashboardData.bookings.findIndex(b => b.id === currentBookingData.id);
            if (bookingIndex !== -1) {
                dashboardData.bookings[bookingIndex].status = newStatus;
                
                // Update filtered data if it exists
                if (filteredData) {
                    const filteredIndex = filteredData.bookings.findIndex(b => b.id === currentBookingData.id);
                    if (filteredIndex !== -1) {
                        filteredData.bookings[filteredIndex].status = newStatus;
                    }
                }
                
                // Save the updated booking data to localStorage
                saveBookingDataToStorage();
                
                // Trigger notifications
                triggerBookingNotification(currentBookingData, newStatus);
                
                // Refresh calendar
                renderCalendar();
                
                // Refresh all booking list widgets
                refreshAllBookingListWidgets();
                
                // Close modal
                closeModal('bookingDetailsModal');
                
                showToast(`Booking ${newStatus} successfully!`, 'success');
                
                // Auto-save
                triggerAutoSave();
            }
        }

        function saveBookingDataToStorage() {
            try {
                localStorage.setItem('bookingData', JSON.stringify(dashboardData));
                console.log('Booking data saved to localStorage');
            } catch (error) {
                console.error('Error saving booking data:', error);
            }
        }

        function loadBookingDataFromStorage() {
            try {
                const savedData = localStorage.getItem('bookingData');
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    // Merge with existing data, keeping the structure intact
                    if (parsedData.bookings && Array.isArray(parsedData.bookings)) {
                        dashboardData.bookings = parsedData.bookings;
                        filteredData = { ...dashboardData };
                        console.log('Booking data loaded from localStorage');
                    }
                }
            } catch (error) {
                console.error('Error loading booking data:', error);
            }
        }

        function triggerBookingNotification(booking, newStatus) {
            // Placeholder for notification functions
            switch(newStatus) {
                case 'confirmed':
                    sendBookingConfirmationEmail(booking);
                    sendBookingConfirmationWhatsApp(booking);
                    break;
                case 'cancelled':
                    sendBookingCancellationEmail(booking);
                    sendBookingCancellationWhatsApp(booking);
                    break;
                case 'pending':
                    sendBookingPendingEmail(booking);
                    break;
            }
        }

        // Notification placeholder functions
        function sendBookingConfirmationEmail(booking) {
            console.log('Email notification: Booking confirmed for', booking.customerName);
            // TODO: Integrate with email service
        }

        function sendBookingConfirmationWhatsApp(booking) {
            console.log('WhatsApp notification: Booking confirmed for', booking.customerName);
            // TODO: Integrate with WhatsApp API
        }

        function sendBookingCancellationEmail(booking) {
            console.log('Email notification: Booking cancelled for', booking.customerName);
            // TODO: Integrate with email service
        }

        function sendBookingCancellationWhatsApp(booking) {
            console.log('WhatsApp notification: Booking cancelled for', booking.customerName);
            // TODO: Integrate with WhatsApp API
        }

        function sendBookingPendingEmail(booking) {
            console.log('Email notification: Booking marked as pending for', booking.customerName);
            // TODO: Integrate with email service
        }

        // Override the refreshWidget function to handle calendar widgets
        const originalRefreshWidget = refreshWidget;
        refreshWidget = function(widgetId) {
            if (widgetId.includes('calendar')) {
                renderCalendar();
                return;
            }
            originalRefreshWidget(widgetId);
        };
    </script>
</body>
</html>
